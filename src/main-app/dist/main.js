/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-snapshot@1.13.3/node_modules/@garfish/browser-snapshot/dist/esm/index.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-snapshot@1.13.3/node_modules/@garfish/browser-snapshot/dist/esm/index.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GarfishBrowserSnapshot\": () => (/* binding */ GarfishBrowserSnapshot),\n/* harmony export */   \"default\": () => (/* binding */ Sandbox)\n/* harmony export */ });\n// src/patchers/event.ts\nvar rawAddEventListener;\nvar rawRemoveEventListener;\nvar PatchEvent = class {\n  constructor() {\n    this.listenerMap = /* @__PURE__ */ new Map();\n  }\n  activate() {\n    this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.addEventListener(type, listener)));\n    if (!rawAddEventListener || !rawRemoveEventListener) {\n      rawAddEventListener = window.addEventListener;\n      rawRemoveEventListener = window.removeEventListener;\n    }\n    window.addEventListener = (type, listener, options) => {\n      const listeners = this.listenerMap.get(type) || [];\n      this.listenerMap.set(type, [...listeners, listener]);\n      return rawAddEventListener.call(window, type, listener, options);\n    };\n    window.removeEventListener = (type, listener, options) => {\n      const storedTypeListeners = this.listenerMap.get(type);\n      if (storedTypeListeners && storedTypeListeners.length && storedTypeListeners.indexOf(listener) !== -1) {\n        storedTypeListeners.splice(storedTypeListeners.indexOf(listener), 1);\n      }\n      return rawRemoveEventListener.call(window, type, listener, options);\n    };\n  }\n  deactivate() {\n    this.listenerMap.forEach((listeners, type) => [...listeners].forEach((listener) => window.removeEventListener(type, listener)));\n    window.removeEventListener = rawRemoveEventListener;\n    window.addEventListener = rawAddEventListener;\n  }\n};\n\n// src/patchers/interceptor.ts\nfunction isStyledComponentsLike(element) {\n  var _a;\n  return element instanceof HTMLStyleElement && !element.textContent && ((_a = element.sheet) == null ? void 0 : _a.cssRules.length);\n}\nvar Snapshot = class {\n  constructor(arrDoms) {\n    this.arrDoms = arrDoms;\n    this.arrDoms = arrDoms;\n  }\n  static take(target = document.head) {\n    let list;\n    if (target.childNodes) {\n      list = Array.prototype.slice.call(target.childNodes);\n    } else {\n      list = Array.prototype.slice.call(target);\n    }\n    return new Snapshot(list);\n  }\n  diff(s) {\n    if (!s) {\n      return {\n        created: new Snapshot([]),\n        removed: new Snapshot([])\n      };\n    }\n    return {\n      created: new Snapshot(this.arrDoms.filter((d) => s.arrDoms.indexOf(d) === -1)),\n      removed: new Snapshot(s.arrDoms.filter((d) => this.arrDoms.indexOf(d) === -1))\n    };\n  }\n};\nvar Interceptor = class {\n  constructor(dom = document.head) {\n    this.dom = dom;\n    this.dom = dom;\n    this.dynamicStyleSheetElementSet = /* @__PURE__ */ new Set();\n    this.styledComponentCSSRulesMap = /* @__PURE__ */ new WeakMap();\n  }\n  add(createdOrSnapshot, removed) {\n    let created;\n    if (!removed) {\n      const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);\n      created = diff.created;\n      removed = diff.removed;\n    } else {\n      created = createdOrSnapshot;\n    }\n    created.arrDoms.reduce((prev, val) => {\n      var _a, _b;\n      prev.appendChild(val);\n      if (val instanceof HTMLStyleElement) {\n        const cssRules = this.styledComponentCSSRulesMap.get(val);\n        if (cssRules && cssRules.length) {\n          for (let i = 0; i < cssRules.length; i++) {\n            const cssRule = cssRules[i];\n            (_b = val.sheet) == null ? void 0 : _b.insertRule(cssRule.cssText, (_a = val.sheet) == null ? void 0 : _a.cssRules.length);\n          }\n        }\n      }\n      return prev;\n    }, this.dom);\n    removed.arrDoms.reduce((prev, val) => {\n      prev.removeChild(val);\n      return prev;\n    }, this.dom);\n  }\n  remove(createdOrSnapshot, removed) {\n    let created;\n    if (!removed) {\n      const diff = Snapshot.take(this.dom).diff(createdOrSnapshot);\n      created = diff.created;\n      removed = diff.removed;\n    } else {\n      created = createdOrSnapshot;\n    }\n    created.arrDoms.reduce((prev, val) => {\n      var _a;\n      if (val instanceof HTMLStyleElement && isStyledComponentsLike(val) && ((_a = val == null ? void 0 : val.sheet) == null ? void 0 : _a.cssRules)) {\n        this.styledComponentCSSRulesMap.set(val, val.sheet.cssRules);\n      }\n      prev.removeChild(val);\n      return prev;\n    }, this.dom);\n    removed.arrDoms.reduce((prev, val) => {\n      prev.appendChild(val);\n      return prev;\n    }, this.dom);\n  }\n};\n\n// src/patchers/style.ts\nvar PatchStyle = class {\n  constructor() {\n    this.headInterceptor = new Interceptor(document.head);\n  }\n  activate() {\n    this.domSnapshotBefore = Snapshot.take();\n    if (this.domSnapshotMutated)\n      this.headInterceptor.add(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);\n  }\n  deactivate() {\n    const domSnapshot = Snapshot.take();\n    this.domSnapshotMutated = domSnapshot.diff(this.domSnapshotBefore);\n    if (!this.domSnapshotMutated)\n      return;\n    this.headInterceptor.remove(this.domSnapshotMutated.created, this.domSnapshotMutated.removed);\n  }\n  formateCtx(arrDoms) {\n    const effectMap = {\n      style: [],\n      script: [],\n      other: []\n    };\n    arrDoms.forEach((dom) => {\n      let type = \"other\";\n      if (/css/.test(dom.type))\n        type = \"style\";\n      if (/javascript/.test(dom.type))\n        type = \"script\";\n      effectMap[type].push({\n        src: dom.src,\n        outerHTML: dom.outerHTML,\n        content: dom.innerText\n      });\n    });\n    return effectMap;\n  }\n};\n\n// src/patchers/history.ts\nvar rawPushState;\nvar rawReplaceState;\nvar PatchHistory = class {\n  activate() {\n    if (!rawPushState || !rawReplaceState) {\n      rawPushState = window.history.pushState;\n      rawReplaceState = window.history.replaceState;\n    }\n  }\n  deactivate() {\n    window.history.pushState = rawPushState;\n    window.history.replaceState = rawReplaceState;\n  }\n};\n\n// src/patchers/interval.ts\nvar rawInterval = window.setInterval;\nvar rawClearInterval = window.clearInterval;\nvar PatchInterval = class {\n  constructor() {\n    this.intervals = [];\n  }\n  activate() {\n    window.setInterval = (handler, timeout, ...args) => {\n      const intervalId = rawInterval(handler, timeout, ...args);\n      this.intervals = [...this.intervals, intervalId];\n      return intervalId;\n    };\n    window.clearInterval = (intervalId) => {\n      this.intervals = this.intervals.filter((id) => id !== intervalId);\n      return rawClearInterval(intervalId);\n    };\n  }\n  deactivate(_clearEffects) {\n    if (_clearEffects) {\n      this.intervals.forEach((id) => window.clearInterval(id));\n    }\n    window.setInterval = rawInterval;\n    window.clearInterval = rawClearInterval;\n  }\n};\n\n// src/patchers/variable.ts\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nvar PatchGlobalVal = class {\n  constructor(targetToProtect = typeof window !== \"undefined\" ? window : globalThis, protectVariable = []) {\n    this.targetToProtect = targetToProtect;\n    this.protectVariable = protectVariable;\n    this.snapshotOriginal = /* @__PURE__ */ new Map();\n    this.snapshotMutated = /* @__PURE__ */ new Map();\n    this.whiteList = [\n      \"location\",\n      \"addEventListener\",\n      \"removeEventListener\",\n      \"webpackJsonp\"\n    ];\n    this.targetToProtect = targetToProtect;\n    this.protectVariable = protectVariable;\n    this.whiteList = [...this.whiteList, ...protectVariable];\n  }\n  safeIterator(fn) {\n    for (const i in this.targetToProtect) {\n      if (this.whiteList.indexOf(i) !== -1) {\n        continue;\n      }\n      const prop = Object.getOwnPropertyDescriptor(this.targetToProtect, i);\n      if (!prop || !prop.writable) {\n        continue;\n      }\n      if (hasOwn(this.targetToProtect, i)) {\n        fn(i);\n      }\n    }\n  }\n  activate() {\n    this.safeIterator((i) => {\n      this.snapshotOriginal.set(i, this.targetToProtect[i]);\n    });\n    this.snapshotMutated.forEach((val, mutateKey) => {\n      this.targetToProtect[mutateKey] = this.snapshotMutated.get(mutateKey);\n    });\n  }\n  deactivate() {\n    const deleteMap = {};\n    const updateMap = {};\n    const addMap = {};\n    this.safeIterator((normalKey) => {\n      if (this.snapshotOriginal.get(normalKey) !== this.targetToProtect[normalKey]) {\n        this.snapshotMutated.set(normalKey, this.targetToProtect[normalKey]);\n        this.targetToProtect[normalKey] = this.snapshotOriginal.get(normalKey);\n        if (this.targetToProtect[normalKey] === void 0) {\n          addMap[normalKey] = this.snapshotMutated.get(normalKey);\n        } else {\n          updateMap[normalKey] = this.snapshotMutated.get(normalKey);\n        }\n      }\n      this.snapshotOriginal.delete(normalKey);\n    });\n    this.snapshotOriginal.forEach((val, deleteKey) => {\n      this.snapshotMutated.set(deleteKey, this.targetToProtect[deleteKey]);\n      this.targetToProtect[deleteKey] = this.snapshotOriginal.get(deleteKey);\n      deleteMap[deleteKey] = this.targetToProtect[deleteKey];\n    });\n  }\n};\n\n// src/patchers/webpackjsonp.ts\nvar PatchWebpackJsonp = class {\n  activate() {\n    this.preWebpackJsonp = window.webpackJsonp;\n    window.webpackJsonp = this.currentWebpackJsonp;\n  }\n  deactivate() {\n    this.currentWebpackJsonp = window.webpackJsonp;\n    window.webpackJsonp = this.preWebpackJsonp;\n  }\n};\n\n// src/sandbox.ts\nvar Sandbox = class {\n  constructor(name, protectVariable = [], targetToProtect = typeof window !== \"undefined\" ? window : globalThis, isInBrowser = typeof window === \"undefined\" ? false : true) {\n    this.name = name;\n    this.protectVariable = protectVariable;\n    this.targetToProtect = targetToProtect;\n    this.isInBrowser = isInBrowser;\n    this.type = \"snapshot\";\n    this.isRunning = false;\n    this.patchList = [];\n    this.name = name;\n    this.isInBrowser = isInBrowser;\n    this.patchList.push(new PatchGlobalVal(targetToProtect, protectVariable));\n    if (this.isInBrowser) {\n      this.patchList = [\n        ...this.patchList,\n        new PatchStyle(),\n        new PatchEvent(),\n        new PatchHistory(),\n        new PatchInterval(),\n        new PatchWebpackJsonp()\n      ];\n    }\n  }\n  activate() {\n    if (this.isRunning)\n      return;\n    this.patchList.forEach((patch) => {\n      patch.activate();\n    });\n    this.isRunning = true;\n  }\n  deactivate(clearEffects = true) {\n    if (!this.isRunning)\n      return;\n    [...this.patchList].reverse().forEach((patch) => {\n      patch.deactivate(clearEffects);\n    });\n    this.isRunning = false;\n  }\n};\n\n// src/index.ts\nfunction GarfishBrowserSnapshot(op) {\n  return function(Garfish) {\n    const options = {\n      openBrowser: false,\n      version: \"1.13.3\",\n      name: \"browser-snapshot\",\n      afterLoad(appInfo, appInstance) {\n        var _a;\n        const config = op || { open: true };\n        const sandboxConfig = appInfo.sandbox || ((_a = Garfish == null ? void 0 : Garfish.options) == null ? void 0 : _a.sandbox);\n        if (sandboxConfig === false || sandboxConfig.open === false || (sandboxConfig == null ? void 0 : sandboxConfig.snapshot) === false) {\n          config.open = false;\n        }\n        if (sandboxConfig) {\n          config.protectVariable = [\n            ...(Garfish == null ? void 0 : Garfish.options.protectVariable) || [],\n            ...appInfo.protectVariable || []\n          ];\n        }\n        options.openBrowser = !!config.open;\n        if (!config.open)\n          return;\n        if (appInstance) {\n          if (appInstance.snapshotSandbox)\n            return;\n          const sandbox = new Sandbox(appInfo.name, config.protectVariable);\n          appInstance.snapshotSandbox = sandbox;\n        }\n      },\n      beforeMount(appInfo, appInstance) {\n        if (!appInstance.snapshotSandbox)\n          return;\n        appInstance.snapshotSandbox.activate();\n      },\n      afterUnmount(appInfo, appInstance) {\n        if (!appInstance.snapshotSandbox)\n          return;\n        appInstance.snapshotSandbox.deactivate();\n      }\n    };\n    return options;\n  };\n}\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-snapshot@1.13.3/node_modules/@garfish/browser-snapshot/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-vm@1.13.3/node_modules/@garfish/browser-vm/dist/esm/index.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-vm@1.13.3/node_modules/@garfish/browser-vm/dist/esm/index.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GarfishBrowserVm\": () => (/* binding */ GarfishBrowserVm),\n/* harmony export */   \"default\": () => (/* binding */ Sandbox)\n/* harmony export */ });\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\n/* harmony import */ var _garfish_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @garfish/loader */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+loader@1.13.3/node_modules/@garfish/loader/dist/esm/index.js\");\n/* harmony import */ var _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @garfish/hooks */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/pluginify.ts\n\n\n// src/sandbox.ts\n\n\n\n// src/modules/history.ts\n\n\n// src/proxyInterceptor/shared.ts\n\n\n// src/utils.ts\n\n\n// src/symbolTypes.ts\nvar GARFISH_NAMESPACE_PREFIX = \"__Garfish__\";\nvar GARFISH_OPTIMIZE_NAME = \"__garfish_optimize__\";\nvar __proxyNode__ = Symbol.for(\"garfish.proxyNode\");\nvar __domWrapper__ = Symbol.for(\"garfish.domWrapper\");\nvar __windowBind__ = Symbol.for(\"garfish.windowBind\");\nvar __sandboxMap__ = Symbol.for(\"garfish.sandboxMap\");\nvar __documentBind__ = Symbol.for(\"garfish.documentBind\");\nvar __garfishGlobal__ = Symbol.for(\"garfish.globalObject\");\nvar __elementSandboxTag__ = Symbol.for(\"garfish.elementSandboxTag\");\n\n// src/utils.ts\nvar esGlobalMethods = \"eval,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Array,ArrayBuffer,BigInt,BigInt64Array,BigUint64Array,Boolean,DataView,Date,Error,EvalError,FinalizationRegistry,Float32Array,Float64Array,Function,Int8Array,Int16Array,Int32Array,Map,Number,Object,Promise,Proxy,RangeError,ReferenceError,RegExp,Set,SharedArrayBuffer,String,Symbol,SyntaxError,TypeError,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,URIError,WeakMap,WeakRef,WeakSet,Atomics,JSON,Math,Reflect,\".split(\",\");\nvar nativeCodeMethods = \"hasOwnProperty,\".split(\",\");\nvar isEsGlobalMethods = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(esGlobalMethods);\nvar isNativeCodeMethods = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(nativeCodeMethods);\nvar optimizeMethods = [...esGlobalMethods].filter((v) => v !== \"eval\");\nvar sandboxList = /* @__PURE__ */ new Map();\nif (!window[__sandboxMap__]) {\n  window[__sandboxMap__] = sandboxList;\n} else {\n  sandboxList = window[__sandboxMap__];\n}\nvar sandboxMap = {\n  sandboxMap: sandboxList,\n  get(element) {\n    if (!element)\n      return;\n    const sandboxId = element[__elementSandboxTag__];\n    if (typeof sandboxId !== \"number\")\n      return;\n    return this.sandboxMap.get(sandboxId);\n  },\n  setElementTag(element, sandbox) {\n    if (!element)\n      return;\n    element[__elementSandboxTag__] = sandbox.id;\n  },\n  set(sandbox) {\n    if (this.sandboxMap.get(sandbox.id))\n      return;\n    this.sandboxMap.set(sandbox.id, sandbox);\n  },\n  del(sandbox) {\n    this.sandboxMap.delete(sandbox.id);\n  }\n};\nfunction handlerParams(args) {\n  args = Array.isArray(args) ? args : Array.from(args);\n  return args.map((v) => {\n    return v && v[__proxyNode__] ? v[__proxyNode__] : v;\n  });\n}\nfunction rootElm(sandbox) {\n  const container = sandbox && sandbox.options.el;\n  return container && container();\n}\nfunction createFakeObject(target, filter, isWritable) {\n  const fakeObject = {};\n  const propertyMap = {};\n  const storageBox = /* @__PURE__ */ Object.create(null);\n  const propertyNames = Object.getOwnPropertyNames(target);\n  const def2 = (p) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, p);\n    if (descriptor == null ? void 0 : descriptor.configurable) {\n      const hasGetter = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(descriptor, \"get\");\n      const hasSetter = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(descriptor, \"set\");\n      const canWritable = typeof isWritable === \"function\" && isWritable(p);\n      if (hasGetter) {\n        descriptor.get = () => (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(storageBox, p) ? storageBox[p] : target[p];\n      }\n      if (hasSetter) {\n        descriptor.set = (val) => {\n          storageBox[p] = val;\n          return true;\n        };\n      }\n      if (canWritable) {\n        if (descriptor.writable === false) {\n          descriptor.writable = true;\n        } else if (hasGetter) {\n          descriptor.set = (val) => {\n            storageBox[p] = val;\n            return true;\n          };\n        }\n      }\n      Object.defineProperty(fakeObject, p, Object.freeze(descriptor));\n    }\n  };\n  propertyNames.forEach((p) => {\n    propertyMap[p] = true;\n    typeof filter === \"function\" ? !filter(p) && def2(p) : def2(p);\n  });\n  for (const prop in target) {\n    !propertyMap[prop] && def2(prop);\n  }\n  return fakeObject;\n}\nvar setting = true;\nfunction microTaskHtmlProxyDocument(proxyDocument) {\n  const html = document.children[0];\n  if (html && html.parentNode !== proxyDocument) {\n    Object.defineProperty(html, \"parentNode\", {\n      value: proxyDocument,\n      configurable: true\n    });\n    if (setting) {\n      setting = false;\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n        setting = true;\n        Object.defineProperty(html, \"parentNode\", {\n          value: document,\n          configurable: true\n        });\n      });\n    }\n  }\n}\nfunction isStyledComponentsLike(element) {\n  var _a;\n  return element instanceof HTMLStyleElement && !element.textContent && ((_a = element.sheet) == null ? void 0 : _a.cssRules.length);\n}\nvar LockQueue = class {\n  constructor() {\n    this.id = 0;\n    this.lockQueue = [];\n  }\n  genId() {\n    const lockId = this.id;\n    let promiseResolve = () => {\n    };\n    const waiting = new Promise((resolve) => {\n      promiseResolve = resolve;\n    });\n    const lockItem = {\n      id: lockId,\n      waiting,\n      resolve: () => {\n        promiseResolve();\n        this.next();\n      }\n    };\n    this.lockQueue.push(lockItem);\n    this.id += 1;\n    return lockId;\n  }\n  getId() {\n    return this.id;\n  }\n  async wait(id2) {\n    const { lockQueue } = this;\n    const firstLock = lockQueue[0];\n    if ((firstLock == null ? void 0 : firstLock.id) === id2) {\n      this.lockQueue.shift();\n      this.next();\n      return;\n    }\n    ;\n    let lockItem = lockQueue.find((item) => item.id === id2);\n    if (lockItem) {\n      await lockItem.waiting;\n    }\n  }\n  release(id2) {\n    const { lockQueue } = this;\n    const findIndex = lockQueue.findIndex((item) => item.id === id2);\n    lockQueue.splice(findIndex, 1);\n    if (findIndex === 0) {\n      this.next();\n    }\n  }\n  next() {\n    const firstLock = this.lockQueue.shift();\n    firstLock && firstLock.resolve();\n  }\n  clear() {\n    this.lockQueue = [];\n  }\n};\n\n// src/proxyInterceptor/shared.ts\nfunction isDataDescriptor(desc) {\n  if (desc === void 0)\n    return false;\n  return \"value\" in desc || \"writable\" in desc;\n}\nfunction isAccessorDescriptor(desc) {\n  if (desc === void 0)\n    return false;\n  return \"get\" in desc || \"set\" in desc;\n}\nfunction verifyGetterDescriptor(target, p, newValue) {\n  const desc = Object.getOwnPropertyDescriptor(target, p);\n  if (desc !== void 0 && desc.configurable === false) {\n    if (isDataDescriptor(desc) && desc.writable === false) {\n      if (!Object.is(newValue, desc.value)) {\n        if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`property \"${String(p)}\" is non-configurable and non-writable.`);\n        }\n        return 1;\n      }\n    } else if (isAccessorDescriptor(desc) && desc.get === void 0) {\n      return 2;\n    }\n  }\n  return 0;\n}\nfunction verifySetter(proxyTarget, target, p, val, receiver) {\n  const verifyResult = verifySetterDescriptor(proxyTarget ? proxyTarget : receiver || target, p, val);\n  let result;\n  if (verifyResult > 0) {\n    if (verifyResult === 1 || verifyResult === 2)\n      result = false;\n    if (verifyResult === 3)\n      result = true;\n  }\n  return result;\n}\nfunction verifySetterDescriptor(target, p, newValue) {\n  const desc = Object.getOwnPropertyDescriptor(target, p);\n  if (desc !== void 0 && desc.configurable === false) {\n    if (isDataDescriptor(desc) && desc.writable === false) {\n      if (!Object.is(newValue, desc.value)) {\n        if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`property \"${String(p)}\" is non-configurable and non-writable.`);\n        }\n        return 1;\n      } else {\n        return 3;\n      }\n    } else if (isAccessorDescriptor(desc) && desc.set === void 0) {\n      return 2;\n    }\n  }\n  return 0;\n}\nfunction safeToString(thing) {\n  try {\n    return thing.toString();\n  } catch (e) {\n    return \"[toString failed]\";\n  }\n}\nfunction isConstructor(fn) {\n  const fp = fn.prototype;\n  const hasConstructor = fp && fp.constructor === fn && Object.getOwnPropertyNames(fp).length > 1;\n  const functionStr = !hasConstructor && safeToString(fn);\n  return hasConstructor || /^function\\s+[A-Z]/.test(functionStr) || /^class\\b/.test(functionStr);\n}\nvar buildInProps = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\n  \"length\",\n  \"caller\",\n  \"callee\",\n  \"arguments\",\n  \"prototype\",\n  Symbol.hasInstance\n]);\nfunction transferProps(o, n) {\n  for (const key of Reflect.ownKeys(o)) {\n    if (buildInProps(key))\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(n, key);\n    if (desc && desc.writable) {\n      n[key] = o[key];\n    }\n  }\n}\nfunction bind(fn, context) {\n  const fNOP = function() {\n  };\n  function bound() {\n    const args = handlerParams(arguments);\n    if (this instanceof bound) {\n      const obj = new fn(...args);\n      Object.setPrototypeOf(obj, bound.prototype);\n      return obj;\n    } else {\n      return fn.apply(context, args);\n    }\n  }\n  bound.$native = fn;\n  transferProps(fn, bound);\n  if (fn.prototype) {\n    fNOP.prototype = fn.prototype;\n  }\n  bound.prototype = new fNOP();\n  if (Symbol.hasInstance) {\n    Object.defineProperty(bound, Symbol.hasInstance, {\n      configurable: true,\n      value(instance) {\n        const op = fn.prototype;\n        return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(op) || typeof op === \"function\" ? instance instanceof fn : false;\n      }\n    });\n  }\n  return bound;\n}\n\n// src/modules/history.ts\nvar passedKey = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\"scrollRestoration\"]);\nfunction historyModule() {\n  const proto = Object.getPrototypeOf(window.history) || History.prototype;\n  const fakeHistory = Object.create(proto);\n  const proxyHistory = new Proxy(fakeHistory, {\n    get(target, p) {\n      const value = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, p) ? target[p] : window.history[p];\n      return typeof value === \"function\" ? value.bind(window.history) : value;\n    },\n    set(target, p, value, receiver) {\n      const isPassKey = typeof p === \"string\" && passedKey(p);\n      const verifySetterResult = verifySetter(isPassKey ? history : null, target, p, value, receiver);\n      if (verifySetterResult !== void 0) {\n        return verifySetterResult;\n      } else {\n        return isPassKey ? Reflect.set(history, p, value) : Reflect.set(target, p, value, receiver);\n      }\n    },\n    getPrototypeOf() {\n      return fakeHistory;\n    }\n  });\n  const fakeHistoryCtor = function History2() {\n    throw new TypeError(\"Illegal constructor\");\n  };\n  fakeHistoryCtor.prototype = fakeHistory;\n  fakeHistoryCtor.prototype.constructor = fakeHistoryCtor;\n  return {\n    override: {\n      history: proxyHistory,\n      History: fakeHistoryCtor\n    }\n  };\n}\n\n// src/modules/network.ts\n\nfunction networkModule(sandbox) {\n  const baseUrl = sandbox.options.baseUrl;\n  const wsSet = /* @__PURE__ */ new Set();\n  const xhrSet = /* @__PURE__ */ new Set();\n  const fetchSet = /* @__PURE__ */ new Set();\n  const needFix = (url) => sandbox.options.fixBaseUrl && baseUrl && typeof url === \"string\" && !(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(url);\n  class fakeXMLHttpRequest extends XMLHttpRequest {\n    constructor() {\n      super();\n      xhrSet.add(this);\n    }\n    open() {\n      if (arguments[2] === false) {\n        xhrSet.delete(this);\n      }\n      if (needFix(arguments[1])) {\n        arguments[1] = baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, arguments[1]) : arguments[1];\n      }\n      const url = arguments[1];\n      if (sandbox.options.addSourceList) {\n        sandbox.options.addSourceList({\n          tagName: \"xmlhttprequest\",\n          url\n        });\n      }\n      return super.open.apply(this, arguments);\n    }\n    abort() {\n      xhrSet.delete(this);\n      return super.abort.apply(this, arguments);\n    }\n  }\n  class fakeWebSocket extends WebSocket {\n    constructor(url, protocols) {\n      if (needFix(url) && baseUrl) {\n        const baseWsUrl = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.toWsProtocol)(baseUrl);\n        url = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseWsUrl, arguments[1]);\n      }\n      super(url, protocols);\n      wsSet.add(this);\n    }\n    close() {\n      wsSet.delete(this);\n      return super.close.apply(this, arguments);\n    }\n  }\n  const fakeFetch = (input, options = {}) => {\n    if (needFix(input) && baseUrl) {\n      input = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, input);\n    }\n    if (sandbox.options.addSourceList) {\n      sandbox.options.addSourceList({\n        tagName: \"fetch\",\n        url: input instanceof Request ? input.url : input\n      });\n    }\n    let controller;\n    if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(options, \"signal\") && window.AbortController) {\n      controller = new window.AbortController();\n      fetchSet.add(controller);\n      options.signal = controller.signal;\n    }\n    const result = window.fetch(input, options);\n    return controller && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isPromise)(result) ? result.finally(() => fetchSet.delete(controller)) : result;\n  };\n  return {\n    override: {\n      WebSocket: fakeWebSocket,\n      XMLHttpRequest: fakeXMLHttpRequest,\n      fetch: fakeFetch\n    },\n    recover() {\n      wsSet.forEach((ws) => {\n        if (typeof ws.close === \"function\")\n          ws.close();\n      });\n      xhrSet.forEach((xhr) => {\n        if (typeof xhr.abort === \"function\")\n          xhr.abort();\n      });\n      fetchSet.forEach((ctor) => {\n        if (typeof ctor.abort === \"function\")\n          ctor.abort();\n      });\n      wsSet.clear();\n      xhrSet.clear();\n      fetchSet.clear();\n    }\n  };\n}\n\n// src/proxyInterceptor/document.ts\n\nvar passedKey2 = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\"title\", \"cookie\", \"onselectstart\", \"ondragstart\"]);\nvar queryFunctions = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\n  \"querySelector\",\n  \"querySelectorAll\",\n  \"getElementById\",\n  \"getElementsByTagName\",\n  \"getElementsByTagNameNS\",\n  \"getElementsByClassName\"\n]);\nfunction createGetter(sandbox) {\n  return (target, p, receiver) => {\n    if (p === \"activeElement\") {\n      return Reflect.get(document, p);\n    }\n    const rootNode = rootElm(sandbox);\n    const strictIsolation = sandbox.options.strictIsolation;\n    const value = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, p) ? Reflect.get(target, p, receiver) : Reflect.get(document, p);\n    const hooksRes = sandbox.hooks.lifecycle.documentGetter.emit({\n      value,\n      rootNode,\n      propName: p,\n      proxyDocument: target,\n      customValue: null\n    });\n    if (hooksRes.customValue) {\n      return hooksRes.customValue;\n    }\n    const setSandboxRef = (el) => {\n      if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(el)) {\n        sandboxMap.setElementTag(el, sandbox);\n        if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          el.__SANDBOX__ = true;\n        }\n      }\n      return el;\n    };\n    if (rootNode) {\n      if (p === \"createElement\") {\n        return function(tagName, options) {\n          const el = value.call(document, tagName, options);\n          return setSandboxRef(el);\n        };\n      } else if (p === \"createTextNode\") {\n        return function(data) {\n          const el = value.call(document, data);\n          return setSandboxRef(el);\n        };\n      } else if (p === \"head\") {\n        return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(rootNode, [\"head\", `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockHead__}]`]) || value;\n      }\n      if (strictIsolation) {\n        if (p === \"body\") {\n          return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(rootNode, [\"body\", `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockBody__}]`]);\n        } else if (queryFunctions(p)) {\n          return p === \"getElementById\" ? (id2) => rootNode.querySelector(`#${id2}`) : rootNode[p].bind(rootNode);\n        }\n      }\n    }\n    if (typeof value === \"function\") {\n      let newValue = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, __documentBind__) ? value[__documentBind__] : null;\n      if (!newValue)\n        newValue = bind(value, document);\n      const verifyResult = verifyGetterDescriptor(target, p, newValue);\n      if (verifyResult > 0) {\n        if (verifyResult === 1)\n          return value;\n        if (verifyResult === 2)\n          return void 0;\n      }\n      value[__documentBind__] = newValue;\n      return newValue;\n    }\n    return value;\n  };\n}\nvar safariProxyDocumentDealHandler = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safari13Deal)();\nfunction createSetter(sandbox) {\n  return (target, p, value, receiver) => {\n    const rootNode = rootElm(sandbox);\n    const verifyResult = verifySetterDescriptor(typeof p === \"string\" && passedKey2(p) ? document : receiver || target, p, value);\n    if (verifyResult > 0) {\n      if (verifyResult === 1 || verifyResult === 2)\n        return false;\n      if (verifyResult === 3)\n        return true;\n    }\n    if (p === \"onselectstart\" || p === \"ondragstart\") {\n      if (rootNode) {\n        return Reflect.set(rootNode, p, value);\n      } else {\n        return Reflect.set(document, p, value);\n      }\n    }\n    if (typeof p === \"string\" && passedKey2(p)) {\n      return Reflect.set(document, p, value);\n    } else {\n      safariProxyDocumentDealHandler.triggerSet();\n      return Reflect.set(target, p, value, receiver);\n    }\n  };\n}\nfunction createDefineProperty() {\n  return (target, p, descriptor) => {\n    safariProxyDocumentDealHandler.handleDescriptor(descriptor);\n    return passedKey2(p) ? Reflect.defineProperty(document, p, descriptor) : Reflect.defineProperty(target, p, descriptor);\n  };\n}\nfunction createHas() {\n  return (target, p) => {\n    if (p === \"activeElement\")\n      return Reflect.has(document, p);\n    return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, p) || Reflect.has(document, p);\n  };\n}\n\n// src/modules/document.ts\nvar documentModule = (sandbox) => {\n  let proxyDocument = Object.create(document);\n  const getter = createGetter(sandbox);\n  const fakeDocument = createFakeObject(document);\n  const fakeDocumentProto = new Proxy(fakeDocument, {\n    get: (...args) => {\n      microTaskHtmlProxyDocument(proxyDocument);\n      return getter(...args);\n    },\n    has: createHas()\n  });\n  proxyDocument = new Proxy(Object.create(fakeDocumentProto, {\n    currentScript: {\n      value: null,\n      writable: true\n    },\n    [__proxyNode__]: {\n      writable: false,\n      configurable: false,\n      value: document\n    }\n  }), {\n    set: createSetter(sandbox),\n    defineProperty: createDefineProperty(),\n    getPrototypeOf() {\n      return HTMLDocument.prototype || Document.prototype;\n    }\n  });\n  return {\n    override: {\n      document: proxyDocument\n    }\n  };\n};\n\n// src/modules/uiEvent.ts\n\nvar MouseEventPatch = class extends MouseEvent {\n  constructor(typeArg, mouseEventInit) {\n    if (mouseEventInit && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.getType)(mouseEventInit.view) === \"window\") {\n      mouseEventInit.view = window;\n    }\n    super(typeArg, mouseEventInit);\n  }\n};\nfunction UiEventOverride() {\n  return {\n    override: {\n      MouseEvent: MouseEventPatch\n    }\n  };\n}\n\n// src/modules/storage.ts\nvar CusStorage = class {\n  constructor(namespace, rawStorage) {\n    this.rawStorage = rawStorage;\n    this.namespace = namespace;\n    this.prefix = `${GARFISH_NAMESPACE_PREFIX}${namespace}__`;\n  }\n  get length() {\n    return this.getKeys().length;\n  }\n  getKeys() {\n    return Object.keys(this.rawStorage).filter((key) => key.startsWith(this.prefix));\n  }\n  key(n) {\n    const key = this.getKeys()[n];\n    return key ? key.substring(this.prefix.length) : null;\n  }\n  getItem(keyName) {\n    return this.rawStorage.getItem(`${this.prefix + keyName}`);\n  }\n  setItem(keyName, keyValue) {\n    this.rawStorage.setItem(`${this.prefix + keyName}`, keyValue);\n  }\n  removeItem(keyName) {\n    this.rawStorage.removeItem(`${this.prefix + keyName}`);\n  }\n  clear() {\n    this.getKeys().forEach((key) => {\n      this.rawStorage.removeItem(key);\n    });\n  }\n};\nfunction localStorageModule(sandbox) {\n  const namespace = sandbox.options.namespace;\n  return {\n    override: {\n      localStorage: new CusStorage(namespace, localStorage),\n      sessionStorage: new CusStorage(namespace, sessionStorage)\n    }\n  };\n}\n\n// src/modules/eventListener.ts\nfunction listenerModule(_sandbox) {\n  const listeners = /* @__PURE__ */ new Map();\n  const rawAddEventListener = window.addEventListener;\n  const rawRemoveEventListener = window.removeEventListener;\n  function addListener(type, listener, options) {\n    const curListeners = listeners.get(type) || [];\n    listeners.set(type, [...curListeners, listener]);\n    rawAddEventListener.call(this, type, listener, options);\n  }\n  function removeListener(type, listener, options) {\n    const curListeners = listeners.get(type) || [];\n    const idx = curListeners.indexOf(listener);\n    if (idx !== -1) {\n      curListeners.splice(idx, 1);\n    }\n    listeners.set(type, [...curListeners]);\n    rawRemoveEventListener.call(this, type, listener, options);\n  }\n  const recover = () => {\n    listeners.forEach((listener, key) => {\n      listener.forEach((fn) => {\n        rawRemoveEventListener.call(window, key, fn);\n      });\n    });\n    listeners.clear();\n  };\n  return {\n    recover,\n    override: {\n      addEventListener: addListener.bind(window),\n      removeEventListener: removeListener.bind(window)\n    },\n    created(global) {\n      const fakeDocument = global == null ? void 0 : global.document;\n      if (fakeDocument) {\n        fakeDocument.addEventListener = addListener.bind(document);\n        fakeDocument.removeEventListener = removeListener.bind(document);\n      }\n    }\n  };\n}\n\n// src/modules/mutationObserver.ts\nfunction observerModule(_sandbox) {\n  const observerSet = /* @__PURE__ */ new Set();\n  class ProxyMutationObserver extends MutationObserver {\n    constructor(cb) {\n      super(cb);\n      observerSet.add(this);\n    }\n  }\n  const recover = () => {\n    observerSet.forEach((observer) => {\n      if (typeof observer.disconnect === \"function\")\n        observer.disconnect();\n    });\n    observerSet.clear();\n  };\n  return {\n    recover,\n    override: {\n      MutationObserver: ProxyMutationObserver\n    }\n  };\n}\n\n// src/modules/timer.ts\nvar rawSetTimeout = window.setTimeout;\nvar rawClearTimeout = window.clearTimeout;\nvar rawSetInterval = window.setInterval;\nvar rawClearInterval = window.clearInterval;\nvar timeoutModule = () => {\n  const timeout = /* @__PURE__ */ new Set();\n  const setTimeout2 = (handler, ms, ...args) => {\n    const timeoutId = rawSetTimeout(handler, ms, ...args);\n    timeout.add(timeoutId);\n    return timeoutId;\n  };\n  const clearTimeout = (timeoutId) => {\n    timeout.delete(timeoutId);\n    rawClearTimeout(timeoutId);\n  };\n  const recover = () => {\n    timeout.forEach((timeoutId) => {\n      rawClearTimeout(timeoutId);\n    });\n  };\n  return {\n    recover,\n    override: {\n      setTimeout: setTimeout2,\n      clearTimeout\n    }\n  };\n};\nvar intervalModule = () => {\n  const timeout = /* @__PURE__ */ new Set();\n  const setInterval = (callback, ms, ...args) => {\n    const intervalId = rawSetInterval(callback, ms, ...args);\n    timeout.add(intervalId);\n    return intervalId;\n  };\n  const clearInterval = (intervalId) => {\n    timeout.delete(intervalId);\n    rawClearInterval(intervalId);\n  };\n  const recover = () => {\n    timeout.forEach((intervalId) => {\n      rawClearInterval(intervalId);\n    });\n  };\n  return {\n    recover,\n    override: {\n      setInterval,\n      clearInterval,\n      setImmediate: (fn) => setTimeout(fn, 0)\n    }\n  };\n};\n\n// src/dynamicNode/index.ts\n\n\n\n// src/dynamicNode/processParams.ts\nfunction injectHandlerParams() {\n  if (window.MutationObserver) {\n    const rawObserver = window.MutationObserver.prototype.observe;\n    MutationObserver.prototype.observe = function() {\n      return rawObserver.apply(this, handlerParams(arguments));\n    };\n  }\n  const desc = Object.getOwnPropertyDescriptor(window.Document.prototype, \"activeElement\");\n  const rawActiveEl = desc && desc.get;\n  if (rawActiveEl) {\n    Object.defineProperty(window.Document.prototype, \"activeElement\", {\n      get(...args) {\n        return rawActiveEl.apply(handlerParams([this])[0], handlerParams(args));\n      }\n    });\n  }\n}\n\n// src/dynamicNode/processor.ts\n\n\nvar isInsertMethod = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\"insertBefore\", \"insertAdjacentElement\"]);\nvar rawElementMethods = /* @__PURE__ */ Object.create(null);\nvar _DynamicNodeProcessor = class {\n  constructor(el, sandbox, methodName) {\n    this.nativeAppend = rawElementMethods[\"appendChild\"];\n    this.nativeRemove = rawElementMethods[\"removeChild\"];\n    this.el = el;\n    this.sandbox = sandbox;\n    this.methodName = methodName;\n    this.rootElement = rootElm(sandbox) || document;\n    this.DOMApis = new _garfish_utils__WEBPACK_IMPORTED_MODULE_0__.DOMApis(sandbox.global.document);\n    this.tagName = el.tagName ? el.tagName.toLowerCase() : \"\";\n  }\n  is(tag) {\n    return this.tagName === tag;\n  }\n  fixResourceNodeUrl(el) {\n    const baseUrl = this.sandbox.options.baseUrl;\n    if (baseUrl) {\n      const src = el.getAttribute(\"src\");\n      const href = el.getAttribute(\"href\");\n      src && (el.src = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, src));\n      href && (el.href = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, href));\n      const url = el.src || el.href;\n      if (url && this.sandbox.options.addSourceList) {\n        this.sandbox.options.addSourceList({\n          tagName: el.tagName,\n          url\n        });\n      }\n    }\n  }\n  dispatchEvent(type, errInfo) {\n    Promise.resolve().then(() => {\n      var _a;\n      const isError = type === \"error\";\n      let event;\n      if (isError && errInfo) {\n        event = new ErrorEvent(type, __spreadProps(__spreadValues({}, errInfo), {\n          message: (_a = errInfo.error) == null ? void 0 : _a.message\n        }));\n      } else {\n        event = new Event(type);\n      }\n      event.__byGarfish__ = true;\n      Object.defineProperty(event, \"target\", { value: this.el });\n      this.el.dispatchEvent(event);\n      isError && window.dispatchEvent(event);\n    });\n  }\n  addDynamicLinkNode(callback) {\n    const { href, type } = this.el;\n    if (!type || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isCssType)({ src: href, type })) {\n      if (href) {\n        const { baseUrl, namespace, styleScopeId } = this.sandbox.options;\n        const fetchUrl = baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, href) : href;\n        const lockId = _DynamicNodeProcessor.linkLock.genId();\n        this.sandbox.loader.load({\n          scope: namespace,\n          url: fetchUrl,\n          defaultContentType: type\n        }).then(async ({ resourceManager: styleManager }) => {\n          await _DynamicNodeProcessor.linkLock.wait(lockId);\n          if (styleManager) {\n            styleManager.correctPath();\n            if (styleScopeId) {\n              styleManager.setScope({\n                appName: namespace,\n                rootElId: styleScopeId()\n              });\n            }\n            callback(styleManager.renderAsStyleElement());\n          } else {\n            (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Invalid resource type \"${type}\", \"${href}\" can't generate styleManager`);\n          }\n          this.dispatchEvent(\"load\");\n        }).catch((e) => {\n          _DynamicNodeProcessor.linkLock.release(lockId);\n          (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(e);\n          this.dispatchEvent(\"error\", {\n            error: e,\n            filename: fetchUrl\n          });\n        });\n      }\n    } else {\n      if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Invalid resource type \"${type}\", \"${href}\"`);\n      }\n    }\n    const linkCommentNode = this.DOMApis.createLinkCommentNode(href);\n    this.el[_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__REMOVE_NODE__] = () => this.DOMApis.removeElement(linkCommentNode);\n    return linkCommentNode;\n  }\n  addDynamicScriptNode() {\n    const { src, type, crossOrigin } = this.el;\n    const isModule2 = type === \"module\";\n    const code = this.el.textContent || this.el.text || \"\";\n    if (!type || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isJsType)({ src, type })) {\n      const { baseUrl, namespace } = this.sandbox.options;\n      if (src) {\n        const fetchUrl = baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.transformUrl)(baseUrl, src) : src;\n        this.sandbox.loader.load({\n          scope: namespace,\n          url: fetchUrl,\n          crossOrigin,\n          defaultContentType: type\n        }).then((manager) => {\n          if (manager.resourceManager) {\n            const {\n              resourceManager: { url, scriptCode }\n            } = manager;\n            this.sandbox.execScript(scriptCode, {}, url, {\n              isModule: isModule2,\n              noEntry: true,\n              originScript: this.el\n            });\n          } else {\n            (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Invalid resource type \"${type}\", \"${src}\" can't generate scriptManager`);\n          }\n          this.dispatchEvent(\"load\");\n        }, (e) => {\n          (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(e);\n          this.dispatchEvent(\"error\", {\n            error: e,\n            filename: fetchUrl\n          });\n        });\n      } else if (code) {\n        this.sandbox.execScript(code, {}, baseUrl, { noEntry: true, originScript: this.el });\n      }\n      const scriptCommentNode = this.DOMApis.createScriptCommentNode({\n        src,\n        code\n      });\n      this.el[_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__REMOVE_NODE__] = () => this.DOMApis.removeElement(scriptCommentNode);\n      return scriptCommentNode;\n    }\n    return this.el;\n  }\n  monitorChangesOfLinkNode() {\n    if (this.el.modifyFlag)\n      return;\n    const mutator = new MutationObserver((mutations) => {\n      var _a;\n      if (this.el.modifyFlag)\n        return;\n      for (const { type, attributeName } of mutations) {\n        if (type === \"attributes\") {\n          if (attributeName === \"rel\" || attributeName === \"stylesheet\") {\n            if (this.el.modifyFlag)\n              return;\n            if (this.el.rel === \"stylesheet\" && this.el.href) {\n              this.el.disabled = this.el.modifyFlag = true;\n              const commentNode = this.addDynamicLinkNode((styleNode) => {\n                var _a2;\n                (_a2 = commentNode.parentNode) == null ? void 0 : _a2.replaceChild(styleNode, commentNode);\n              });\n              (_a = this.el.parentNode) == null ? void 0 : _a.replaceChild(commentNode, this.el);\n            }\n          }\n        }\n      }\n    });\n    mutator.observe(this.el, { attributes: true });\n  }\n  monitorChangesOfStyle() {\n    const { baseUrl, namespace, styleScopeId } = this.sandbox.options;\n    const rootElId = styleScopeId == null ? void 0 : styleScopeId();\n    const modifyStyleCode = (styleCode) => {\n      if (styleCode) {\n        const manager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_1__.StyleManager(styleCode);\n        manager.correctPath(baseUrl);\n        if (rootElId) {\n          manager.setScope({\n            rootElId,\n            appName: namespace\n          });\n        }\n        styleCode = manager.transformCode(styleCode);\n      }\n      return styleCode;\n    };\n    const mutator = new MutationObserver((mutations) => {\n      var _a;\n      for (const { type, target, addedNodes } of mutations) {\n        if (type === \"childList\") {\n          const el = target;\n          if (isStyledComponentsLike(el) && el.sheet) {\n            const originAddRule = el.sheet.insertRule;\n            el.sheet.insertRule = function() {\n              arguments[0] = modifyStyleCode(arguments[0]);\n              return originAddRule.apply(this, arguments);\n            };\n          } else {\n            if ((_a = addedNodes[0]) == null ? void 0 : _a.textContent) {\n              addedNodes[0].textContent = modifyStyleCode(addedNodes[0].textContent);\n            }\n          }\n        }\n      }\n    });\n    mutator.observe(this.el, { childList: true });\n  }\n  findParentNodeInApp(parentNode, defaultInsert) {\n    if (parentNode === document.body) {\n      return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(this.rootElement, [\n        \"body\",\n        `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockBody__}]`\n      ]);\n    } else if (parentNode === document.head) {\n      return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(this.rootElement, [\n        \"head\",\n        `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockHead__}]`\n      ]);\n    }\n    if (this.rootElement.contains(parentNode) || !document.contains(parentNode)) {\n      return parentNode;\n    }\n    if (defaultInsert === \"head\") {\n      return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(this.rootElement, [\n        \"head\",\n        `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockHead__}]`\n      ]);\n    } else if (defaultInsert === \"body\") {\n      return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.findTarget)(this.rootElement, [\n        \"body\",\n        `div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__MockBody__}]`\n      ]);\n    }\n    return parentNode;\n  }\n  append(context, args, originProcess) {\n    var _a;\n    let convertedNode;\n    let parentNode = context;\n    const { baseUrl, namespace, styleScopeId } = this.sandbox.options;\n    if (_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.sourceListTags.includes(this.tagName)) {\n      this.fixResourceNodeUrl(this.el);\n    }\n    if (this.is(\"script\")) {\n      parentNode = this.findParentNodeInApp(context, \"body\");\n      convertedNode = this.addDynamicScriptNode();\n    } else if (this.is(\"style\")) {\n      parentNode = this.findParentNodeInApp(context, \"head\");\n      const manager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_1__.StyleManager(this.el.textContent);\n      manager.correctPath(baseUrl);\n      if (styleScopeId) {\n        manager.setScope({\n          appName: namespace,\n          rootElId: styleScopeId()\n        });\n      }\n      this.el.textContent = manager.transformCode(manager.styleCode);\n      convertedNode = this.el;\n      this.sandbox.dynamicStyleSheetElementSet.add(this.el);\n      this.monitorChangesOfStyle();\n    } else if (this.is(\"link\")) {\n      parentNode = this.findParentNodeInApp(context, \"head\");\n      if (this.el.rel === \"stylesheet\" && this.el.href) {\n        convertedNode = this.addDynamicLinkNode((styleNode) => this.nativeAppend.call(parentNode, styleNode));\n      } else {\n        convertedNode = this.el;\n        this.monitorChangesOfLinkNode();\n      }\n    }\n    if (!this.rootElement.contains(parentNode) && document.contains(parentNode)) {\n      if (parentNode !== this.rootElement) {\n        this.sandbox.deferClearEffects.add(() => {\n          this.DOMApis.removeElement(this.el);\n          return this.el;\n        });\n      }\n    }\n    if (this.el && this.el.querySelectorAll) {\n      let needFixDom = this.el.querySelectorAll(\"iframe,img,video,link,script,audio,style\");\n      if (needFixDom.length > 0) {\n        needFixDom.forEach((dom) => {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => this.fixResourceNodeUrl(dom));\n        });\n      }\n    }\n    if (this.is(\"iframe\") && typeof this.el.onload === \"function\") {\n      const { el, sandbox } = this;\n      const originOnload = el.onload;\n      el.onload = function() {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.def)(el.contentWindow, \"parent\", sandbox.global));\n        return originOnload.apply(this, arguments);\n      };\n    }\n    if (convertedNode) {\n      if (isInsertMethod(this.methodName) && this.rootElement.contains(context) && ((_a = args[1]) == null ? void 0 : _a.parentNode) === context) {\n        return originProcess();\n      }\n      this.sandbox.hooks.lifecycle.appendNode.emit(parentNode, this.el, convertedNode, this.tagName);\n      return this.nativeAppend.call(parentNode, convertedNode);\n    }\n    return originProcess();\n  }\n  removeChild(context, originProcess) {\n    if (typeof this.el[_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__REMOVE_NODE__] === \"function\") {\n      this.el[_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.__REMOVE_NODE__]();\n      return this.el;\n    }\n    if (this.is(\"style\") || this.is(\"link\") || this.is(\"script\")) {\n      const parentNode = this.findParentNodeInApp(context, this.is(\"script\") ? \"body\" : \"head\");\n      if (this.el.parentNode === parentNode) {\n        if (this.sandbox.dynamicStyleSheetElementSet.has(this.el)) {\n          this.sandbox.dynamicStyleSheetElementSet.delete(this.el);\n        }\n        return this.nativeRemove.call(parentNode, this.el);\n      }\n    }\n    return originProcess();\n  }\n};\nvar DynamicNodeProcessor = _DynamicNodeProcessor;\nDynamicNodeProcessor.linkLock = new LockQueue();\n\n// src/dynamicNode/index.ts\nvar mountElementMethods = [\n  \"append\",\n  \"appendChild\",\n  \"insertBefore\",\n  \"insertAdjacentElement\"\n];\nvar removeChildElementMethods = [\"removeChild\"];\nvar ignoreElementTimingTags = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)([\n  \"STYLE\",\n  \"SCRIPTS\",\n  \"LINK\",\n  \"META\",\n  \"TITLE\"\n]);\nfunction injector(current, methodName) {\n  return function() {\n    var _a;\n    const el = methodName === \"insertAdjacentElement\" ? arguments[1] : arguments[0];\n    const sandbox = sandboxMap.get(el);\n    const originProcess = () => current.apply(this, arguments);\n    if (sandbox) {\n      if (el && ((_a = this == null ? void 0 : this.tagName) == null ? void 0 : _a.toLowerCase()) === \"style\") {\n        const manager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_1__.StyleManager(el.textContent);\n        const { baseUrl, namespace, styleScopeId } = sandbox.options;\n        manager.correctPath(baseUrl);\n        manager.setScope({\n          appName: namespace,\n          rootElId: styleScopeId()\n        });\n        el.textContent = manager.transformCode(manager.styleCode);\n        return originProcess();\n      } else {\n        const processor = new DynamicNodeProcessor(el, sandbox, methodName);\n        return processor.append(this, arguments, originProcess);\n      }\n    }\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => {\n      if (ignoreElementTimingTags(el.tagName))\n        return;\n      if ((el == null ? void 0 : el.setAttribute) && typeof (el == null ? void 0 : el.setAttribute) === \"function\" && !(el == null ? void 0 : el.getAttribute(\"elementtiming\"))) {\n        el == null ? void 0 : el.setAttribute(\"elementtiming\", sandbox ? `${sandbox.options.namespace}-element-timing` : \"element-timing\");\n      }\n    });\n    if (sandbox) {\n      const processor = new DynamicNodeProcessor(el, sandbox, methodName);\n      return processor.append(this, arguments, originProcess);\n    } else {\n      return originProcess();\n    }\n  };\n}\nfunction injectorRemoveChild(current, methodName) {\n  return function() {\n    const el = arguments[0];\n    const sandbox = el && sandboxMap.get(el);\n    const originProcess = () => {\n      return current.apply(this, arguments);\n    };\n    if (sandbox) {\n      const processor = new DynamicNodeProcessor(el, sandbox, methodName);\n      return processor.removeChild(this, originProcess);\n    }\n    return originProcess();\n  };\n}\nfunction handleOwnerDocument() {\n  Object.defineProperty(window.Element.prototype, \"ownerDocument\", {\n    get() {\n      const sandbox = this && sandboxMap.get(this);\n      const realValue = Reflect.get(window.Node.prototype, \"ownerDocument\", this);\n      return sandbox ? sandbox.global.document : realValue;\n    },\n    set() {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('\"ownerDocument\" is a read-only attribute.');\n    }\n  });\n}\nfunction makeElInjector(sandboxConfig) {\n  if (makeElInjector.hasInject)\n    return;\n  makeElInjector.hasInject = true;\n  if (typeof window.Element === \"function\") {\n    if (sandboxConfig.fixBaseUrl)\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => handleOwnerDocument());\n    const rewrite = (methods, builder) => {\n      for (const name of methods) {\n        const fn = window.Element.prototype[name];\n        if (typeof fn !== \"function\" || fn[__domWrapper__]) {\n          continue;\n        }\n        rawElementMethods[name] = fn;\n        const wrapper = builder(fn, name);\n        wrapper[__domWrapper__] = true;\n        window.Element.prototype[name] = wrapper;\n      }\n    };\n    rewrite(mountElementMethods, injector);\n    rewrite(removeChildElementMethods, injectorRemoveChild);\n  }\n  injectHandlerParams();\n}\nfunction recordStyledComponentCSSRules(dynamicStyleSheetElementSet, styledComponentCSSRulesMap) {\n  dynamicStyleSheetElementSet.forEach((styleElement) => {\n    if (isStyledComponentsLike(styleElement) && styleElement.sheet) {\n      styledComponentCSSRulesMap.set(styleElement, styleElement.sheet.cssRules);\n    }\n  });\n}\nfunction rebuildCSSRules(dynamicStyleSheetElementSet, styledComponentCSSRulesMap) {\n  dynamicStyleSheetElementSet.forEach((styleElement) => {\n    var _a, _b;\n    const cssRules = styledComponentCSSRulesMap.get(styleElement);\n    if (cssRules && (isStyledComponentsLike(styleElement) || cssRules.length)) {\n      for (let i = 0; i < cssRules.length; i++) {\n        const cssRule = cssRules[i];\n        (_b = styleElement.sheet) == null ? void 0 : _b.insertRule(cssRule.cssText, (_a = styleElement.sheet) == null ? void 0 : _a.cssRules.length);\n      }\n    }\n  });\n}\n\n// src/lifecycle.ts\n\nfunction sandboxLifecycle() {\n  return new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.PluginSystem({\n    closed: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    stared: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    appendNode: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    documentGetter: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncWaterfallHook(\"documentGetter\"),\n    beforeClearEffect: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    afterClearEffect: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    beforeInvoke: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    afterInvoke: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook(),\n    invokeError: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_2__.SyncHook()\n  });\n}\n\n// src/proxyInterceptor/global.ts\n\nfunction createGetter2(sandbox) {\n  return (target, p, receiver) => {\n    if (p === Symbol.unscopables)\n      return void 0;\n    let value;\n    const { overrideList } = sandbox.replaceGlobalVariables;\n    if (sandbox.isProtectVariable(p)) {\n      return Reflect.get(window, p);\n    } else if (sandbox.isInsulationVariable(p)) {\n      value = Reflect.get(target, p, receiver);\n    } else {\n      value = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, p) ? Reflect.get(target, p, receiver) : Reflect.get(window, p);\n    }\n    if (typeof value === \"function\") {\n      if (isEsGlobalMethods(p) || isNativeCodeMethods(p) || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(overrideList, p) || isConstructor(value) || sandbox.isExternalGlobalVariable.has(p)) {\n        return value;\n      }\n    } else {\n      return value;\n    }\n    const newValue = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, __windowBind__) ? value[__windowBind__] : bind(value, window);\n    const verifyResult = verifyGetterDescriptor(target, p, newValue);\n    if (verifyResult > 0) {\n      if (verifyResult === 1)\n        return value;\n      if (verifyResult === 2)\n        return void 0;\n    }\n    value[__windowBind__] = newValue;\n    return newValue;\n  };\n}\nvar safariProxyWindowDealHandler = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safari13Deal)();\nfunction createSetter2(sandbox) {\n  return (target, p, value, receiver) => {\n    const verifyResult = verifySetterDescriptor(sandbox.isProtectVariable(p) ? window : receiver ? receiver : target, p, value);\n    if (verifyResult > 0) {\n      if (verifyResult === 1 || verifyResult === 2)\n        return false;\n      if (verifyResult === 3)\n        return true;\n    }\n    if (sandbox.isProtectVariable(p)) {\n      return Reflect.set(window, p, value);\n    } else {\n      safariProxyWindowDealHandler.triggerSet();\n      const success = Reflect.set(target, p, value, receiver);\n      if (success) {\n        if (sandbox.initComplete) {\n          sandbox.isExternalGlobalVariable.add(p);\n        }\n        if (sandbox.global) {\n          const methods = sandbox.global[`${GARFISH_OPTIMIZE_NAME}Methods`];\n          if (Array.isArray(methods)) {\n            if (methods.includes(p)) {\n              const updateStack = sandbox.global[`${GARFISH_OPTIMIZE_NAME}UpdateStack`];\n              updateStack.forEach((fn) => fn(p, value));\n            }\n          }\n        }\n      }\n      return success;\n    }\n  };\n}\nfunction createDefineProperty2(sandbox) {\n  return (target, p, descriptor) => {\n    safariProxyWindowDealHandler.handleDescriptor(descriptor);\n    if (sandbox.isProtectVariable(p)) {\n      return Reflect.defineProperty(window, p, descriptor);\n    } else {\n      const success = Reflect.defineProperty(target, p, descriptor);\n      if (sandbox.initComplete && success) {\n        sandbox.isExternalGlobalVariable.add(p);\n      }\n      return success;\n    }\n  };\n}\nfunction createDeleteProperty(sandbox) {\n  return (target, p) => {\n    if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, p)) {\n      delete target[p];\n      if (sandbox.initComplete && sandbox.isExternalGlobalVariable.has(p)) {\n        sandbox.isExternalGlobalVariable.delete(p);\n      }\n    } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n      if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(window, p) && sandbox.isProtectVariable(p)) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \"${String(p)}\" is global protect variable.\"`);\n      }\n    }\n    return true;\n  };\n}\nfunction createHas2(sandbox) {\n  return (_target, p) => {\n    if (sandbox.isProtectVariable(p))\n      return false;\n    if (sandbox.envVariable === p)\n      return false;\n    return true;\n  };\n}\n\n// src/sandbox.ts\nvar id = 0;\nvar defaultModules = [\n  networkModule,\n  timeoutModule,\n  intervalModule,\n  historyModule,\n  documentModule,\n  listenerModule,\n  observerModule,\n  UiEventOverride,\n  localStorageModule\n];\nvar isModule = (module) => {\n  return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(module) ? module[__garfishGlobal__] !== void 0 : false;\n};\nvar addProxyWindowType = (module, parentModule) => {\n  if (!isModule(module)) {\n    module[__garfishGlobal__] = parentModule;\n  }\n  return module;\n};\nvar Sandbox = class {\n  constructor(options) {\n    this.id = id++;\n    this.type = \"vm\";\n    this.closed = true;\n    this.initComplete = false;\n    this.version = \"1.13.3\";\n    this.hooks = sandboxLifecycle();\n    this.deferClearEffects = /* @__PURE__ */ new Set();\n    this.isExternalGlobalVariable = /* @__PURE__ */ new Set();\n    this.dynamicStyleSheetElementSet = /* @__PURE__ */ new Set();\n    this.styledComponentCSSRulesMap = /* @__PURE__ */ new WeakMap();\n    this.optimizeCode = \"\";\n    this.envVariable = \"__GARFISH_SANDBOX_ENV_VAR__\";\n    const defaultOptions = {\n      baseUrl: \"\",\n      namespace: \"\",\n      modules: [],\n      fixBaseUrl: false,\n      disableWith: false,\n      strictIsolation: false,\n      el: () => null,\n      styleScopeId: () => \"\",\n      protectVariable: () => [],\n      insulationVariable: () => []\n    };\n    this.options = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(options) ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.deepMerge)(defaultOptions, options) : defaultOptions;\n    const { loaderOptions, protectVariable, insulationVariable } = this.options;\n    this.loader = new _garfish_loader__WEBPACK_IMPORTED_MODULE_1__.Loader(loaderOptions);\n    this.isProtectVariable = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)((protectVariable == null ? void 0 : protectVariable()) || []);\n    this.isInsulationVariable = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)((insulationVariable == null ? void 0 : insulationVariable()) || []);\n    this.replaceGlobalVariables = {\n      createdList: [],\n      prepareList: [],\n      recoverList: [],\n      overrideList: {}\n    };\n    makeElInjector(this.options);\n    this.start();\n    sandboxMap.set(this);\n  }\n  start() {\n    this.closed = false;\n    this.replaceGlobalVariables = this.getModuleData();\n    const { createdList, overrideList } = this.replaceGlobalVariables;\n    this.global = this.createProxyWindow(Object.keys(overrideList));\n    if (overrideList && this.global) {\n      for (const key in overrideList) {\n        this.global[key] = overrideList[key];\n      }\n    }\n    if (createdList) {\n      createdList.forEach((fn) => fn && fn(this.global));\n    }\n    if (!this.options.disableWith) {\n      this.optimizeCode = this.optimizeGlobalMethod();\n    }\n    this.initComplete = true;\n    this.hooks.lifecycle.stared.emit(this.global);\n  }\n  close() {\n    if (this.closed)\n      return;\n    this.clearEffects();\n    this.closed = true;\n    this.global = void 0;\n    this.optimizeCode = \"\";\n    this.initComplete = false;\n    this.deferClearEffects.clear();\n    this.isExternalGlobalVariable.clear();\n    this.dynamicStyleSheetElementSet.clear();\n    this.replaceGlobalVariables.createdList = [];\n    this.replaceGlobalVariables.prepareList = [];\n    this.replaceGlobalVariables.recoverList = [];\n    this.replaceGlobalVariables.overrideList = [];\n    this.hooks.lifecycle.closed.emit();\n  }\n  reset() {\n    this.close();\n    this.start();\n  }\n  createProxyWindow(moduleKeys = []) {\n    const fakeWindow = createFakeObject(window, this.isInsulationVariable, (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(moduleKeys));\n    const baseHandlers = {\n      get: createGetter2(this),\n      set: createSetter2(this),\n      defineProperty: createDefineProperty2(this),\n      deleteProperty: createDeleteProperty(this),\n      getPrototypeOf() {\n        return Object.getPrototypeOf(window);\n      }\n    };\n    const parentHandlers = __spreadProps(__spreadValues({}, baseHandlers), {\n      has: createHas2(this),\n      getPrototypeOf() {\n        return Object.getPrototypeOf(window);\n      }\n    });\n    const proxy = new Proxy(fakeWindow, parentHandlers);\n    const subProxy = new Proxy(fakeWindow, baseHandlers);\n    proxy.self = subProxy;\n    proxy.window = subProxy;\n    proxy.globalThis = subProxy;\n    proxy.__debug_sandbox__ = this;\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => {\n      proxy.top = window.top === window ? subProxy : window.top;\n      proxy.parent = window.parent === window ? subProxy : window.parent;\n    });\n    addProxyWindowType(proxy, window);\n    return proxy;\n  }\n  getModuleData() {\n    var _a;\n    const recoverList = [];\n    const createdList = [];\n    const prepareList = [];\n    const overrideList = {};\n    const allModules = defaultModules.concat((_a = this.options.modules) != null ? _a : []);\n    for (const module of allModules) {\n      if (typeof module === \"function\") {\n        const { recover, override, created, prepare } = module(this) || {};\n        if (recover)\n          recoverList.push(recover);\n        if (created)\n          createdList.push(created);\n        if (prepare)\n          prepareList.push(prepare);\n        if (override) {\n          for (const key in override) {\n            if ((typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && overrideList[key]) {\n              (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`\"${key}\" global variables are overwritten.`);\n            }\n            overrideList[key] = override[key];\n          }\n        }\n      }\n    }\n    return { recoverList, createdList, overrideList, prepareList };\n  }\n  clearEffects() {\n    this.hooks.lifecycle.beforeClearEffect.emit();\n    this.replaceGlobalVariables.recoverList.forEach((fn) => fn && fn());\n    this.deferClearEffects.forEach((fn) => fn && fn());\n    this.hooks.lifecycle.afterClearEffect.emit();\n  }\n  optimizeGlobalMethod(tempEnvKeys = []) {\n    let code = \"\";\n    const methods = optimizeMethods.filter((p) => {\n      return p && !this.isProtectVariable(p) && !tempEnvKeys.includes(p) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(this.global, p);\n    });\n    if (methods.length > 0) {\n      code = methods.reduce((prevCode, name) => {\n        return `${prevCode} let ${name} = window.${name};`;\n      }, code);\n      if (this.global) {\n        this.global[`${GARFISH_OPTIMIZE_NAME}Methods`] = methods;\n        this.global[`${GARFISH_OPTIMIZE_NAME}UpdateStack`] = [];\n      }\n      code += `window.${GARFISH_OPTIMIZE_NAME}UpdateStack.push(function(k,v){eval(k+\"=v\")});`;\n    }\n    if (tempEnvKeys.length > 0) {\n      code = tempEnvKeys.reduce((prevCode, name) => {\n        return `${prevCode} let ${name} = ${this.envVariable}.${name};`;\n      }, code);\n    }\n    return code;\n  }\n  createExecParams(codeRef, env) {\n    const { disableWith } = this.options;\n    const { prepareList, overrideList } = this.replaceGlobalVariables;\n    if (prepareList) {\n      prepareList.forEach((fn) => fn && fn());\n    }\n    const params = __spreadValues({\n      window: this.global\n    }, overrideList);\n    if (disableWith) {\n      Object.assign(params, env);\n    } else {\n      const envKeys = Object.keys(env);\n      const optimizeCode = envKeys.length > 0 ? this.optimizeGlobalMethod(envKeys) : this.optimizeCode;\n      codeRef.code = `with(window) {;${optimizeCode + codeRef.code}\n}`;\n      params[this.envVariable] = env;\n    }\n    return params;\n  }\n  processExecError(e, url, env, options) {\n    this.hooks.lifecycle.invokeError.emit(e, url, env, options);\n    if (this.global && typeof this.global.onerror === \"function\") {\n      const source = url || this.options.baseUrl;\n      const message = e instanceof Error ? e.message : String(e);\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.safeWrapper)(() => {\n        var _a, _b;\n        (_b = (_a = this.global) == null ? void 0 : _a.onerror) == null ? void 0 : _b.call(this.global, message, source, null, null, e);\n      });\n    }\n    throw e;\n  }\n  execScript(code, env = {}, url = \"\", options) {\n    var _a;\n    const codeRef = { code };\n    const { async } = options || {};\n    this.hooks.lifecycle.beforeInvoke.emit(codeRef, url, env, options);\n    const revertCurrentScript = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.setDocCurrentScript)((_a = this.global) == null ? void 0 : _a.document, codeRef.code, false, url, async, options == null ? void 0 : options.originScript);\n    try {\n      const params = this.createExecParams(codeRef, env);\n      codeRef.code += `\n${url ? `//# sourceURL=${url}\n` : \"\"}`;\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.evalWithEnv)(codeRef.code, params, this.global);\n    } catch (e) {\n      this.processExecError(e, url, env, options);\n    } finally {\n      Promise.resolve().then(revertCurrentScript);\n    }\n    this.hooks.lifecycle.afterInvoke.emit(codeRef, url, env, options);\n  }\n  static getNativeWindow() {\n    let module = window;\n    while (isModule(module)) {\n      module = module[__garfishGlobal__];\n    }\n    return module;\n  }\n  static canSupport() {\n    let support = true;\n    if (!window.Proxy || !Array.prototype.includes || !String.prototype.includes) {\n      support = false;\n    }\n    if (support) {\n      try {\n        new Function(\"let a = 666;\");\n      } catch (e) {\n        support = false;\n      }\n    }\n    if (!support) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('The current environment does not support \"vm sandbox\",Please use the \"snapshot sandbox\" instead.');\n    }\n    return support;\n  }\n};\n\n// src/pluginify.ts\nvar specialExternalVariables = [\n  \"onerror\",\n  \"webpackjsonp\",\n  \"__REACT_ERROR_OVERLAY_GLOBAL_HOOK__\",\n  (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) ? \"webpackHotUpdate\" : \"\"\n];\nfunction compatibleOldModule(modules) {\n  if (!Array.isArray(modules)) {\n    (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('\"vm sandbox\" modules should be an array');\n    const list = [];\n    for (const key in modules) {\n      list.push(modules[key]);\n    }\n    modules = list;\n  }\n  return modules;\n}\nfunction rewriteAppAndSandbox(Garfish, app, sandbox) {\n  var _a;\n  const originExecScript = sandbox.execScript;\n  sandbox.loader = Garfish.loader;\n  sandbox.execScript = (code, env, url, options) => {\n    const evalHooksArgs = [app.appInfo, code, env, url, options];\n    app.hooks.lifecycle.beforeEval.emit(...evalHooksArgs);\n    try {\n      const res = originExecScript.call(sandbox, code, __spreadValues(__spreadValues({}, env), app.getExecScriptEnv(options == null ? void 0 : options.noEntry)), url, options);\n      app.hooks.lifecycle.afterEval.emit(...evalHooksArgs);\n      return res;\n    } catch (err) {\n      app.hooks.lifecycle.errorExecCode.emit(err, ...evalHooksArgs);\n      throw err;\n    }\n  };\n  app.vmSandbox = sandbox;\n  app.global = sandbox.global;\n  app.strictIsolation = (_a = sandbox.options.strictIsolation) != null ? _a : false;\n  app.runCode = function() {\n    return originExecScript.apply(sandbox, arguments);\n  };\n  if (app.entryManager.DOMApis && sandbox.global) {\n    app.entryManager.DOMApis.document = sandbox.global.document;\n  }\n}\nfunction createOptions(Garfish) {\n  const canSupport = Sandbox.canSupport();\n  const options = {\n    name: \"browser-vm\",\n    version: \"1.13.3\",\n    afterLoad(appInfo, appInstance) {\n      var _a, _b, _c, _d;\n      if (!canSupport || !appInstance || (appInstance == null ? void 0 : appInstance.vmSandbox) || appInfo.sandbox === false || appInfo.sandbox && appInfo.sandbox.open === false || appInfo.sandbox && appInfo.sandbox.snapshot) {\n        if (appInstance == null ? void 0 : appInstance.vmSandbox) {\n          appInstance.global = appInstance.vmSandbox.global;\n        }\n        return;\n      }\n      rewriteAppAndSandbox(Garfish, appInstance, new Sandbox({\n        namespace: appInfo.name,\n        addSourceList: appInstance.addSourceList.bind(appInstance),\n        baseUrl: appInstance.entryManager.url,\n        modules: compatibleOldModule(((_a = appInfo.sandbox) == null ? void 0 : _a.modules) || []),\n        fixBaseUrl: Boolean((_b = appInfo.sandbox) == null ? void 0 : _b.fixBaseUrl),\n        disableWith: Boolean((_c = appInfo.sandbox) == null ? void 0 : _c.disableWith),\n        strictIsolation: Boolean((_d = appInfo.sandbox) == null ? void 0 : _d.strictIsolation),\n        el: () => appInstance.htmlNode,\n        styleScopeId: () => appInstance.appContainer.id,\n        protectVariable: () => appInfo.protectVariable || [],\n        insulationVariable: () => {\n          return [\n            ...specialExternalVariables,\n            ...appInfo.insulationVariable || []\n          ].filter(Boolean);\n        }\n      }));\n    },\n    beforeUnmount(appInfo, appInstance) {\n      if (appInstance.vmSandbox) {\n        recordStyledComponentCSSRules(appInstance.vmSandbox.dynamicStyleSheetElementSet, appInstance.vmSandbox.styledComponentCSSRulesMap);\n      }\n    },\n    afterUnmount(appInfo, appInstance, isCacheMode) {\n      if (appInstance.vmSandbox && !isCacheMode) {\n        appInstance.vmSandbox.reset();\n      }\n    },\n    afterMount(appInfo, appInstance) {\n      if (appInstance.vmSandbox) {\n        rebuildCSSRules(appInstance.vmSandbox.dynamicStyleSheetElementSet, appInstance.vmSandbox.styledComponentCSSRulesMap);\n        appInstance.vmSandbox.execScript(`\n          if (typeof window.onload === 'function') {\n            window.onload.call(window);\n          }\n        `);\n      }\n    }\n  };\n  return options;\n}\nfunction GarfishBrowserVm() {\n  return function(Garfish) {\n    Garfish.getGlobalObject = function() {\n      return Sandbox.getNativeWindow();\n    };\n    Garfish.setGlobalValue = function(key, value) {\n      return this.getGlobalObject()[key] = value;\n    };\n    Garfish.clearEscapeEffect = function(key, value) {\n      const global = this.getGlobalObject();\n      if (key in global) {\n        global[key] = value;\n      }\n    };\n    return createOptions(Garfish);\n  };\n}\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-vm@1.13.3/node_modules/@garfish/browser-vm/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+core@1.13.3/node_modules/@garfish/core/dist/esm/index.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+core@1.13.3/node_modules/@garfish/core/dist/esm/index.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Garfish)\n/* harmony export */ });\n/* harmony import */ var _garfish_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/loader */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+loader@1.13.3/node_modules/@garfish/loader/dist/esm/index.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter2 */ \"./node_modules/.pnpm/registry.npmmirror.com+eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\n/* harmony import */ var _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @garfish/hooks */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js\");\n/* harmony import */ var _alioth_org_es_module_lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @alioth-org/es-module-lexer */ \"./node_modules/.pnpm/registry.npmmirror.com+@alioth-org+es-module-lexer@1.1.0/node_modules/@alioth-org/es-module-lexer/dist/lexer.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/garfish.ts\n\n\n\n\n\n// src/config.ts\n\nvar filterAppConfigKeys = {\n  beforeBootstrap: true,\n  bootstrap: true,\n  beforeRegisterApp: true,\n  registerApp: true,\n  beforeLoad: true,\n  afterLoad: true,\n  errorLoadApp: true,\n  appID: true,\n  apps: true,\n  disableStatistics: true,\n  disablePreloadApp: true,\n  plugins: true,\n  autoRefreshApp: true,\n  onNotMatchRouter: true,\n  loader: true\n};\nvar deepMergeConfig = (globalConfig, localConfig) => {\n  const props = __spreadValues(__spreadValues({}, globalConfig.props || {}), localConfig.props || {});\n  const result = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.deepMerge)((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.filterUndefinedVal)(globalConfig), (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.filterUndefinedVal)(localConfig));\n  result.props = props;\n  return result;\n};\nvar getAppConfig = (globalConfig, localConfig) => {\n  const mergeResult = deepMergeConfig(globalConfig, localConfig);\n  Object.keys(mergeResult).forEach((key) => {\n    if (filterAppConfigKeys[key]) {\n      delete mergeResult[key];\n    }\n  });\n  return mergeResult;\n};\nvar generateAppOptions = (appName, garfish, options) => {\n  let appInfo = garfish.appInfos[appName] || { name: appName };\n  appInfo = getAppConfig(garfish.options, __spreadProps(__spreadValues(__spreadValues({}, appInfo), options), {\n    props: __spreadValues(__spreadValues({}, appInfo.props || {}), (options == null ? void 0 : options.props) || {})\n  }));\n  return appInfo;\n};\nvar createDefaultOptions = () => {\n  const config = {\n    appID: \"\",\n    apps: [],\n    autoRefreshApp: true,\n    disableStatistics: false,\n    disablePreloadApp: false,\n    basename: \"/\",\n    props: {},\n    domGetter: () => document.createElement(\"div\"),\n    sandbox: {\n      snapshot: false,\n      fixBaseUrl: false,\n      disableWith: false,\n      strictIsolation: false\n    },\n    beforeLoad: () => {\n    },\n    afterLoad: () => {\n    },\n    errorLoadApp: (e) => (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.error)(e),\n    onNotMatchRouter: () => {\n    },\n    beforeEval: () => {\n    },\n    afterEval: () => {\n    },\n    beforeMount: () => {\n    },\n    afterMount: () => {\n    },\n    beforeUnmount: () => {\n    },\n    afterUnmount: () => {\n    },\n    errorMountApp: (e) => (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.error)(e),\n    errorUnmountApp: (e) => (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.error)(e),\n    customLoader: void 0\n  };\n  return config;\n};\n\n// src/module/app.ts\n\n\n\n// src/lifecycle.ts\n\nfunction globalLifecycle() {\n  return new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.PluginSystem({\n    beforeBootstrap: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    bootstrap: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    beforeRegisterApp: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    registerApp: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    beforeLoad: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.AsyncHook(),\n    afterLoad: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.AsyncHook(),\n    errorLoadApp: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook()\n  });\n}\nfunction appLifecycle() {\n  return new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.PluginSystem({\n    beforeEval: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    afterEval: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    beforeMount: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    afterMount: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    errorMountApp: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    beforeUnmount: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    afterUnmount: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    errorUnmountApp: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    errorExecCode: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook(),\n    customRender: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncWaterfallHook(\"customRender\")\n  });\n}\n\n// src/module/esModule.ts\n\n\n\nvar __GARFISH_ESM_ENV__ = \"__GARFISH_ESM_ENV__\";\nvar getModuleImportProcessor = (code) => {\n  let finalCode = \"\";\n  let resetCode = code;\n  let prevCodeIndex = 0;\n  const rawImport = \"import\";\n  const wrapImport = \"_import_\";\n  return (importAnalysis, newModuleName = \"\") => {\n    const { d: importType, n: moduleName, s, e, ss, se } = importAnalysis;\n    const isDynamicImport = importType > -1;\n    if (isDynamicImport) {\n      const codeStart = ss - prevCodeIndex;\n      const codeEnd = se - prevCodeIndex;\n      const dynamicImportStatement = resetCode.slice(codeStart, codeEnd);\n      finalCode += resetCode.slice(0, codeStart);\n      finalCode += dynamicImportStatement.replace(rawImport, wrapImport);\n      resetCode = resetCode.slice(codeEnd);\n      prevCodeIndex = se;\n    } else if (moduleName) {\n      const codeStart = s - prevCodeIndex;\n      const codeEnd = e - prevCodeIndex;\n      finalCode += resetCode.slice(0, codeStart);\n      finalCode += newModuleName;\n      resetCode = resetCode.slice(codeEnd);\n      prevCodeIndex = e;\n    }\n    return [finalCode, resetCode];\n  };\n};\nvar genShellExecutionCode = (id, sourceModuleName, shellUrl) => `;import*as m$$_${id} from'${sourceModuleName}';import{u$$_ as u$$_${id}}from'${shellUrl}';u$$_${id}(m$$_${id})`;\nvar ESModuleLoader = class {\n  constructor(app) {\n    this.moduleCache = {};\n    this.lock = new _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.Lock();\n    this.app = app;\n    this.globalVarKey = `${__GARFISH_ESM_ENV__}_${this.app.appId}`;\n  }\n  execModuleCode(blobUrl) {\n    const result = (0, eval)(`import('${blobUrl}')`);\n    this.lock.release();\n    return result;\n  }\n  createBlobUrl(code) {\n    return URL.createObjectURL(new Blob([code], { type: \"text/javascript\" }));\n  }\n  setBlobUrl(saveId, blobUrl) {\n    this.moduleCache[saveId].blobUrl = blobUrl;\n  }\n  async fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl) {\n    const { resourceManager } = await this.app.context.loader.load({\n      scope: this.app.name,\n      url: requestUrl\n    });\n    if (resourceManager) {\n      let sourcemap = \"\";\n      let { url, scriptCode } = resourceManager;\n      if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.haveSourcemap)(scriptCode)) {\n        sourcemap = await (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.createSourcemap)(scriptCode, requestUrl);\n      }\n      scriptCode = await this.analysisModule(lockId, scriptCode, envVarStr, noEntryEnvVarStr, saveUrl, url);\n      const blobUrl = this.createBlobUrl(`import.meta.url='${url}';${this.app.isNoEntryScript(url) ? noEntryEnvVarStr : envVarStr}${scriptCode}\n${sourcemap}`);\n      this.setBlobUrl(saveUrl, blobUrl);\n    }\n  }\n  getUrl(referUrl, targetUrl) {\n    return !(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isAbsolute)(targetUrl) && referUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(referUrl, targetUrl) : targetUrl;\n  }\n  preloadStaticModuleAsync(analysis, realUrl) {\n    const [imports] = analysis;\n    for (let i = 0, length = imports.length; i < length; i++) {\n      const importAnalysis = imports[i];\n      const { d: importType, n: moduleName } = importAnalysis;\n      const isDynamicImport = importType > -1;\n      if (moduleName && !isDynamicImport) {\n        this.app.context.loader.load({\n          scope: this.app.name,\n          url: this.getUrl(realUrl, moduleName)\n        });\n      }\n    }\n  }\n  async analysisModule(lockId, code, envVarStr, noEntryEnvVarStr, baseUrl, realUrl) {\n    await this.lock.wait(lockId);\n    await (0,_alioth_org_es_module_lexer__WEBPACK_IMPORTED_MODULE_4__.init)();\n    const analysis = (0,_alioth_org_es_module_lexer__WEBPACK_IMPORTED_MODULE_4__.parse)(code, realUrl || \"\");\n    const thisModule = {\n      analysis,\n      source: code\n    };\n    if (baseUrl) {\n      this.moduleCache[baseUrl] = thisModule;\n    }\n    let result = [\"\", code];\n    let shellExecutionCode = \"\";\n    const dynamicImport = `var _import_=(url)=>window.${this.globalVarKey}.import(url,'${baseUrl}','${realUrl}');`;\n    const processImportModule = getModuleImportProcessor(code);\n    const [imports] = analysis;\n    this.preloadStaticModuleAsync(analysis, realUrl);\n    for (let i = 0, length = imports.length; i < length; i++) {\n      const importAnalysis = imports[i];\n      const { d: importType, n: moduleName } = importAnalysis;\n      const isDynamicImport = importType > -1;\n      let saveUrl = moduleName || \"\";\n      let newModuleName = \"\";\n      if (moduleName && !isDynamicImport) {\n        const requestUrl = this.getUrl(realUrl, moduleName);\n        saveUrl = this.getUrl(baseUrl, moduleName);\n        let currentModule = this.moduleCache[saveUrl];\n        if (currentModule && !currentModule.blobUrl) {\n          if (!currentModule.shellUrl) {\n            const [currentModuleImports, currentModuleExports] = currentModule.analysis;\n            const wildcardExports = currentModuleImports.filter((importItem) => {\n              const statement = currentModule.source.substring(importItem.ss, importItem.se);\n              return /^export\\s*\\*\\s*from\\s*/.test(statement);\n            });\n            const wildcardExportStatements = [];\n            for (let j = 0, l = wildcardExports.length; j < l; j++) {\n              const wildcardExport = wildcardExports[j];\n              const wildcardExportUrl = wildcardExport.n || \"\";\n              const wildcardExportSaveUrl = this.getUrl(baseUrl, wildcardExportUrl);\n              await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, wildcardExportSaveUrl, this.getUrl(realUrl, wildcardExportUrl));\n              const wildcardModule = this.moduleCache[wildcardExportSaveUrl];\n              if (wildcardModule == null ? void 0 : wildcardModule.blobUrl) {\n                wildcardExportStatements.push(`export * from '${wildcardModule.blobUrl}'`);\n              }\n            }\n            currentModule.shellUrl = this.createBlobUrl(`export function u$$_(m){${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === \"default\" ? \"d$$_=m.default\" : `${exportSpecifier.n}=m.${exportSpecifier.n}`).join(\",\")}}${currentModuleExports.map((exportSpecifier) => exportSpecifier.n === \"default\" ? \"let d$$_;export{d$$_ as default}\" : `export let ${exportSpecifier.n}`).join(\";\")}${wildcardExportStatements.length ? `;${wildcardExportStatements.join(\";\")}` : \"\"}\n//# sourceURL=${saveUrl}?cycle`);\n          }\n          newModuleName = currentModule.shellUrl;\n        } else if (!currentModule) {\n          await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);\n          currentModule = this.moduleCache[saveUrl];\n          const { blobUrl, shellUrl, shellExecuted } = currentModule;\n          newModuleName = blobUrl;\n          if (shellUrl && !shellExecuted) {\n            shellExecutionCode += genShellExecutionCode(i, newModuleName, shellUrl);\n            currentModule.shellExecuted = true;\n          }\n        } else {\n          newModuleName = currentModule.blobUrl;\n        }\n      }\n      result = processImportModule(importAnalysis, newModuleName || moduleName);\n    }\n    thisModule.source = \"\";\n    delete thisModule.analysis;\n    return `${dynamicImport}${shellExecutionCode};${result.join(\"\")}`;\n  }\n  destroy() {\n    for (const key in this.moduleCache) {\n      const { blobUrl, shellUrl } = this.moduleCache[key];\n      if (blobUrl) {\n        URL.revokeObjectURL(blobUrl);\n      }\n      if (shellUrl) {\n        URL.revokeObjectURL(shellUrl);\n      }\n    }\n    this.moduleCache = {};\n    this.lock.clear();\n    delete this.app.global[this.globalVarKey];\n  }\n  load(code, env, url, options) {\n    return new Promise(async (resolve) => {\n      if (url && this.moduleCache[url]) {\n        return resolve();\n      }\n      const genShellCodeWrapper = (blobUrl2, shellUrl, sourceUrl) => {\n        return `export * from '${blobUrl2}'${genShellExecutionCode(0, blobUrl2, shellUrl)}\n//# sourceURL=${sourceUrl}?cycle`;\n      };\n      env = __spreadProps(__spreadValues({}, env), {\n        resolve,\n        import: async (moduleId, baseUrl, realUrl) => {\n          let saveUrl = moduleId;\n          let requestUrl = moduleId;\n          if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isAbsolute)(moduleId)) {\n            saveUrl = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(baseUrl, moduleId);\n            requestUrl = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(realUrl, moduleId);\n          }\n          let targetModule = this.moduleCache[saveUrl];\n          if (!(targetModule == null ? void 0 : targetModule.blobUrl)) {\n            await this.fetchModuleResource(this.lock.genId(), envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);\n            targetModule = this.moduleCache[saveUrl];\n          }\n          if (targetModule && targetModule.shellUrl && !targetModule.shellExecuted && targetModule.blobUrl) {\n            return this.execModuleCode(this.createBlobUrl(genShellCodeWrapper(targetModule.blobUrl, targetModule.shellUrl, saveUrl)));\n          }\n          return this.execModuleCode(targetModule.blobUrl);\n        }\n      });\n      const genEnvVarStr = (targetEnv, noEntry) => {\n        const newEnv = __spreadValues({}, targetEnv);\n        if (noEntry) {\n          delete newEnv.exports;\n          delete newEnv.module;\n        }\n        return Object.keys(newEnv).reduce((prevCode, name) => {\n          if (name === \"resolve\" || name === \"import\")\n            return prevCode;\n          return `${prevCode} var ${name} = window.${this.globalVarKey}.${name};`;\n        }, \"\");\n      };\n      const envVarStr = genEnvVarStr(env);\n      const noEntryEnvVarStr = genEnvVarStr(env, true);\n      let sourcemap = \"\";\n      if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.haveSourcemap)(code) && url) {\n        sourcemap = await (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.createSourcemap)(code, options && options.isInline ? `index.html(inline.${this.app.scriptCount}.js)` : url);\n      }\n      code = await this.analysisModule(this.lock.genId(), code, envVarStr, noEntryEnvVarStr, url, url);\n      code = `import.meta.url='${url}';${(options == null ? void 0 : options.noEntry) ? noEntryEnvVarStr : envVarStr}${code}\n;window.${this.globalVarKey}.resolve();\n${sourcemap}`;\n      this.app.global[this.globalVarKey] = env;\n      let blobUrl = this.createBlobUrl(code);\n      if (options && !options.isInline && url) {\n        this.setBlobUrl(url, blobUrl);\n      }\n      const currentModule = this.moduleCache[url || \"\"];\n      if ((currentModule == null ? void 0 : currentModule.shellUrl) && !currentModule.shellExecuted) {\n        blobUrl = this.createBlobUrl(genShellCodeWrapper(blobUrl, currentModule.shellUrl, url || \"\"));\n      }\n      this.execModuleCode(blobUrl);\n    });\n  }\n};\n\n// src/module/app.ts\nvar appId = 0;\nvar __GARFISH_GLOBAL_ENV__ = \"__GARFISH_GLOBAL_ENV__\";\nvar __GARFISH_EXPORTS__ = \"__GARFISH_EXPORTS__\";\nvar App = class {\n  constructor(context, appInfo, entryManager, resources, isHtmlMode, customLoader) {\n    this.appId = appId++;\n    this.scriptCount = 0;\n    this.display = false;\n    this.mounted = false;\n    this.strictIsolation = false;\n    this.esmQueue = new _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.Queue();\n    this.esModuleLoader = new ESModuleLoader(this);\n    this.global = window;\n    this.customExports = {};\n    this.sourceList = [];\n    this.sourceListMap = /* @__PURE__ */ new Map();\n    this.childGarfishConfig = {};\n    this.active = false;\n    this.mounting = false;\n    this.unmounting = false;\n    this.context = context;\n    this.appInfo = appInfo;\n    this.name = appInfo.name;\n    this.resources = resources;\n    this.isHtmlMode = isHtmlMode;\n    this.entryManager = entryManager;\n    this.appInfo.appId = this.appId;\n    this.globalEnvVariables = {\n      currentApp: this,\n      loader: context.loader,\n      externals: context.externals,\n      remoteModulesCode: resources.modules\n    };\n    this.cjsModules = {\n      exports: {},\n      module: null,\n      require: (key) => {\n        const pkg = this.global[key] || context.externals[key] || window[key];\n        if (!pkg) {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`Package \"${key}\" is not found`);\n        }\n        return pkg;\n      }\n    };\n    this.cjsModules.module = this.cjsModules;\n    this.customLoader = customLoader;\n    this.hooks = appLifecycle();\n    this.hooks.usePlugin(__spreadProps(__spreadValues({}, appInfo), {\n      name: `${appInfo.name}-lifecycle`\n    }));\n    const nodes = entryManager.getNodesByTagName(..._garfish_utils__WEBPACK_IMPORTED_MODULE_2__.sourceListTags);\n    for (const key in nodes) {\n      nodes[key].forEach((node) => {\n        var _a, _b;\n        const url = entryManager.findAttributeValue(node, \"href\") || entryManager.findAttributeValue(node, \"src\");\n        if (url) {\n          this.addSourceList({\n            tagName: node.tagName,\n            url: entryManager.url ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(entryManager.url, url) : url\n          });\n        }\n        if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isGarfishConfigType)({\n          type: entryManager.findAttributeValue(node, \"type\")\n        })) {\n          this.childGarfishConfig = JSON.parse((_b = (_a = node.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.content);\n        }\n      });\n    }\n    this.appInfo.entry && this.addSourceList({ tagName: \"html\", url: this.appInfo.entry });\n  }\n  get rootElement() {\n    return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.findTarget)(this.htmlNode, [`div[${_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.__MockBody__}]`, \"body\"]);\n  }\n  get getSourceList() {\n    return this.sourceList;\n  }\n  addSourceList(sourceInfo) {\n    if (this.appInfo.disableSourceListCollect)\n      return;\n    if (Array.isArray(sourceInfo)) {\n      const nSourceList = sourceInfo.filter((item) => {\n        const dup = Object.assign({}, item);\n        dup.url = dup.url.startsWith(\"/\") ? `${location.origin}${dup.url}` : dup.url;\n        if (!this.sourceListMap.has(dup.url) && dup.url.startsWith(\"http\")) {\n          this.sourceListMap.set(dup.url, dup);\n          return true;\n        }\n        return false;\n      });\n      this.sourceList = this.sourceList.concat(nSourceList);\n    } else {\n      const dup = Object.assign({}, sourceInfo);\n      dup.url = dup.url.startsWith(\"/\") ? `${location.origin}${dup.url}` : dup.url;\n      if (!this.sourceListMap.get(dup.url) && dup.url.startsWith(\"http\")) {\n        this.sourceList.push(dup);\n        this.sourceListMap.set(dup.url, dup);\n      }\n    }\n  }\n  getProvider() {\n    return this.provider ? Promise.resolve(this.provider) : this.checkAndGetProvider();\n  }\n  isNoEntryScript(url = \"\") {\n    var _a, _b;\n    return (_b = (_a = this.childGarfishConfig.sandbox) == null ? void 0 : _a.noEntryScripts) == null ? void 0 : _b.some((item) => url.indexOf(item) > -1);\n  }\n  execScript(code, env, url, options) {\n    env = __spreadValues(__spreadValues({}, this.getExecScriptEnv(options == null ? void 0 : options.noEntry)), env || {});\n    this.scriptCount++;\n    const args = [this.appInfo, code, env, url, options];\n    this.hooks.lifecycle.beforeEval.emit(...args);\n    try {\n      this.runCode(code, env, url, options);\n    } catch (err) {\n      this.hooks.lifecycle.errorExecCode.emit(err, ...args);\n      throw err;\n    }\n    this.hooks.lifecycle.afterEval.emit(...args);\n  }\n  runCode(code, env, url, options) {\n    if (options && options.isModule) {\n      this.esmQueue.add(async (next) => {\n        await this.esModuleLoader.load(code, __spreadValues(__spreadValues({}, this.getExecScriptEnv()), env), url, options);\n        next();\n      });\n    } else {\n      const revertCurrentScript = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.setDocCurrentScript)(this.global.document, code, true, url, options == null ? void 0 : options.async, options == null ? void 0 : options.originScript);\n      code += url ? `\n//# sourceURL=${url}\n` : \"\";\n      if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(env, \"window\")) {\n        env = __spreadProps(__spreadValues({}, env), {\n          window: this.global\n        });\n      }\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.evalWithEnv)(`;${code}`, env, this.global);\n      Promise.resolve().then(revertCurrentScript);\n    }\n  }\n  async show() {\n    this.active = true;\n    const { display, mounted, provider } = this;\n    if (display)\n      return false;\n    if (!mounted) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)('Need to call the \"app.mount()\" method first.');\n      return false;\n    }\n    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, true);\n    this.context.activeApps.push(this);\n    await this.addContainer();\n    this.callRender(provider, false);\n    this.display = true;\n    this.hooks.lifecycle.afterMount.emit(this.appInfo, this, true);\n    return true;\n  }\n  hide() {\n    this.active = false;\n    this.mounting = false;\n    const { display, mounted, provider } = this;\n    if (!display)\n      return false;\n    if (!mounted) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)('Need to call the \"app.mount()\" method first.');\n      return false;\n    }\n    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, true);\n    this.callDestroy(provider, false);\n    this.display = false;\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.remove)(this.context.activeApps, this);\n    this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, true);\n    return true;\n  }\n  async mount() {\n    if (!this.canMount())\n      return false;\n    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);\n    this.active = true;\n    this.mounting = true;\n    try {\n      this.context.activeApps.push(this);\n      const { asyncScripts } = await this.compileAndRenderContainer();\n      if (!this.stopMountAndClearEffect())\n        return false;\n      const provider = await this.getProvider();\n      if (!this.stopMountAndClearEffect())\n        return false;\n      this.callRender(provider, true);\n      this.display = true;\n      this.mounted = true;\n      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);\n      await asyncScripts;\n      if (!this.stopMountAndClearEffect())\n        return false;\n    } catch (e) {\n      this.entryManager.DOMApis.removeElement(this.appContainer);\n      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);\n      return false;\n    } finally {\n      this.mounting = false;\n    }\n    return true;\n  }\n  unmount() {\n    this.active = false;\n    this.mounting = false;\n    if (!this.mounted || !this.appContainer) {\n      return false;\n    }\n    if (this.unmounting) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The ${this.name} app unmounting.`);\n      return false;\n    }\n    this.unmounting = true;\n    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, false);\n    try {\n      this.callDestroy(this.provider, true);\n      this.display = false;\n      this.mounted = false;\n      this.provider = void 0;\n      this.customExports = {};\n      this.cjsModules.exports = {};\n      this.esModuleLoader.destroy();\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.remove)(this.context.activeApps, this);\n      this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, false);\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.remove)(this.context.activeApps, this);\n      this.entryManager.DOMApis.removeElement(this.appContainer);\n      this.hooks.lifecycle.errorUnmountApp.emit(e, this.appInfo);\n      return false;\n    } finally {\n      this.unmounting = false;\n    }\n    return true;\n  }\n  getExecScriptEnv(noEntry) {\n    const envs = {\n      [__GARFISH_EXPORTS__]: this.customExports,\n      [__GARFISH_GLOBAL_ENV__]: this.globalEnvVariables\n    };\n    if (noEntry) {\n      return __spreadProps(__spreadValues({}, envs), {\n        require: this.cjsModules.require\n      });\n    }\n    return __spreadValues(__spreadValues({}, envs), this.cjsModules);\n  }\n  async compileAndRenderContainer() {\n    await this.renderTemplate();\n    return {\n      asyncScripts: new Promise((resolve) => {\n        setTimeout(() => {\n          if (this.stopMountAndClearEffect()) {\n            for (const jsManager of this.resources.js) {\n              if (jsManager.async) {\n                try {\n                  this.execScript(jsManager.scriptCode, {}, jsManager.url || this.appInfo.entry, {\n                    async: false,\n                    noEntry: true\n                  });\n                } catch (e) {\n                  this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);\n                }\n              }\n            }\n          }\n          resolve();\n        });\n      })\n    };\n  }\n  canMount() {\n    if (this.mounting) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The ${this.appInfo.name} app mounting.`);\n      return false;\n    }\n    if (this.mounted) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The ${this.appInfo.name} app already mounted.`);\n      return false;\n    }\n    if (this.unmounting) {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The ${this.appInfo.name} app is unmounting can't Perform application rendering.`);\n      return false;\n    }\n    return true;\n  }\n  stopMountAndClearEffect() {\n    if (!this.active) {\n      if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The app \"${this.name}\" rendering process has been blocked.`);\n      }\n      this.mounting = false;\n      if (this.appContainer) {\n        this.entryManager.DOMApis.removeElement(this.appContainer);\n      }\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${this.appInfo.name} id:${this.appId} stopMountAndClearEffect`, this.appContainer);\n      return false;\n    }\n    return true;\n  }\n  callRender(provider, isMount) {\n    if (provider && provider.render) {\n      provider.render({\n        appName: this.appInfo.name,\n        dom: this.rootElement,\n        basename: this.appInfo.basename,\n        appRenderInfo: { isMount },\n        props: this.appInfo.props\n      });\n    }\n  }\n  callDestroy(provider, isUnmount) {\n    const { rootElement, appContainer } = this;\n    if (provider && provider.destroy) {\n      provider.destroy({\n        appName: this.appInfo.name,\n        dom: rootElement,\n        appRenderInfo: { isUnmount },\n        props: this.appInfo.props\n      });\n    }\n    this.entryManager.DOMApis.removeElement(appContainer);\n  }\n  async addContainer() {\n    const wrapperNode = await (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.getRenderNode)(this.appInfo.domGetter);\n    if (typeof wrapperNode.appendChild === \"function\") {\n      wrapperNode.appendChild(this.appContainer);\n    }\n  }\n  async renderTemplate() {\n    const { appInfo, entryManager, resources } = this;\n    const { url: baseUrl, DOMApis } = entryManager;\n    const { htmlNode, appContainer } = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.createAppContainer)(appInfo);\n    this.htmlNode = htmlNode;\n    this.appContainer = appContainer;\n    await this.addContainer();\n    const customRenderer = {\n      meta: () => null,\n      img: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, \"src\", baseUrl);\n        return DOMApis.createElement(node);\n      },\n      video: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, \"src\", baseUrl);\n        return DOMApis.createElement(node);\n      },\n      audio: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, \"src\", baseUrl);\n        return DOMApis.createElement(node);\n      },\n      iframe: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, \"src\", baseUrl);\n        return DOMApis.createElement(node);\n      },\n      body: (node) => {\n        if (!this.strictIsolation) {\n          node = entryManager.cloneNode(node);\n          node.tagName = \"div\";\n          node.attributes.push({\n            key: _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.__MockBody__,\n            value: null\n          });\n        }\n        return DOMApis.createElement(node);\n      },\n      head: (node) => {\n        if (!this.strictIsolation) {\n          node = entryManager.cloneNode(node);\n          node.tagName = \"div\";\n          node.attributes.push({\n            key: _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.__MockHead__,\n            value: null\n          });\n        }\n        return DOMApis.createElement(node);\n      },\n      script: (node) => {\n        const mimeType = entryManager.findAttributeValue(node, \"type\");\n        const isModule = mimeType === \"module\";\n        if (mimeType) {\n          if (!isModule && !(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isJsType)({ type: mimeType })) {\n            return DOMApis.createElement(node);\n          }\n        }\n        const jsManager = resources.js.find((manager) => {\n          return !manager.async ? manager.isSameOrigin(node) : false;\n        });\n        if (jsManager) {\n          const { url, scriptCode } = jsManager;\n          const mockOriginScript = document.createElement(\"script\");\n          node.attributes.forEach((attribute) => {\n            if (attribute.key) {\n              mockOriginScript.setAttribute(attribute.key, attribute.value || \"\");\n            }\n          });\n          const targetUrl = url || this.appInfo.entry;\n          this.execScript(scriptCode, {}, targetUrl, {\n            isModule,\n            async: false,\n            isInline: jsManager.isInlineScript(),\n            noEntry: (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.toBoolean)(entryManager.findAttributeValue(node, \"no-entry\") || this.isNoEntryScript(targetUrl)),\n            originScript: mockOriginScript\n          });\n        } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          const async = entryManager.findAttributeValue(node, \"async\");\n          if (typeof async === \"undefined\" || async === \"false\") {\n            const tipInfo = JSON.stringify(node, null, 2);\n            (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`Current js node cannot be found, the resource may not exist.\n\n ${tipInfo}`);\n          }\n        }\n        return DOMApis.createScriptCommentNode(node);\n      },\n      style: (node) => {\n        const text = node.children[0];\n        if (text) {\n          const styleManager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.StyleManager(text.content, baseUrl);\n          styleManager.setScope({\n            appName: this.name,\n            rootElId: this.appContainer.id\n          });\n          baseUrl && styleManager.correctPath(baseUrl);\n          return entryManager.ignoreChildNodesCreation(styleManager.renderAsStyleElement());\n        }\n        return DOMApis.createElement(node);\n      },\n      link: (node) => {\n        if (DOMApis.isCssLinkNode(node)) {\n          const styleManager = this.resources.link.find((manager) => manager.isSameOrigin(node));\n          if (styleManager) {\n            styleManager.setScope({\n              appName: this.name,\n              rootElId: this.appContainer.id\n            });\n            return styleManager.renderAsStyleElement((typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) ? `\n/*${DOMApis.createLinkCommentNode(node)}*/\n` : \"\");\n          }\n        }\n        return DOMApis.isPrefetchJsLinkNode(node) ? DOMApis.createScriptCommentNode(node) : DOMApis.isIconLinkNode(node) ? null : DOMApis.createElement(node);\n      }\n    };\n    entryManager.createElements(customRenderer, htmlNode, (node, parent) => {\n      return this.hooks.lifecycle.customRender.emit({\n        node,\n        parent,\n        app: this,\n        customElement: null\n      });\n    });\n  }\n  async checkAndGetProvider() {\n    const { appInfo, rootElement, cjsModules, customExports } = this;\n    const { name, props, basename } = appInfo;\n    let provider = void 0;\n    await this.esmQueue.awaitCompletion();\n    if (cjsModules.exports) {\n      if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isPromise)(cjsModules.exports))\n        cjsModules.exports = await cjsModules.exports;\n      if (cjsModules.exports.provider)\n        provider = cjsModules.exports.provider;\n    }\n    if (customExports.provider) {\n      provider = customExports.provider;\n    }\n    if (typeof provider === \"function\") {\n      provider = await provider(__spreadValues({\n        basename,\n        dom: rootElement\n      }, props || {}), props);\n    } else if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isPromise)(provider)) {\n      provider = await provider;\n    }\n    if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(provider) && typeof provider !== \"function\") {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(` Invalid module content: ${name}, you should return both render and destroy functions in provider function.`);\n    }\n    const hookRes = await (this.customLoader && this.customLoader(provider, appInfo, basename));\n    if (hookRes) {\n      const { mount, unmount } = hookRes || {};\n      if (typeof mount === \"function\" && typeof unmount === \"function\") {\n        provider.render = mount;\n        provider.destroy = unmount;\n      }\n    }\n    if (!appInfo.noCheckProvider) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(provider, `\"provider\" is \"${provider}\".`);\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(\"render\" in provider, '\"render\" is required in provider.');\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(\"destroy\" in provider, '\"destroy\" is required in provider.');\n    }\n    this.provider = provider;\n    return provider;\n  }\n};\n\n// src/module/resource.ts\n\n\nfunction fetchStaticResources(appName, loader, entryManager) {\n  const isAsync = (val) => typeof val !== \"undefined\" && val !== \"false\";\n  const jsNodes = Promise.all(entryManager.findAllJsNodes().map((node) => {\n    const src = entryManager.findAttributeValue(node, \"src\");\n    const type = entryManager.findAttributeValue(node, \"type\");\n    const crossOrigin = entryManager.findAttributeValue(node, \"crossorigin\");\n    if (src) {\n      const fetchUrl = entryManager.url ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(entryManager.url, src) : src;\n      const async = entryManager.findAttributeValue(node, \"async\");\n      return loader.load({\n        scope: appName,\n        url: fetchUrl,\n        crossOrigin,\n        defaultContentType: type\n      }).then(({ resourceManager: jsManager }) => {\n        if (jsManager) {\n          jsManager.setDep(node);\n          type && jsManager.setMimeType(type);\n          jsManager.setAsyncAttribute(isAsync(async));\n          return jsManager;\n        } else {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`[${appName}] Failed to load script: ${fetchUrl}`);\n        }\n      }).catch(() => null);\n    } else if (node.children.length > 0) {\n      const code = node.children[0].content;\n      if (code) {\n        const jsManager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.JavaScriptManager(code, \"\");\n        jsManager.setDep(node);\n        type && jsManager.setMimeType(type);\n        return jsManager;\n      }\n    }\n  }).filter(Boolean));\n  const linkNodes = Promise.all(entryManager.findAllLinkNodes().map((node) => {\n    if (!entryManager.DOMApis.isCssLinkNode(node))\n      return;\n    const href = entryManager.findAttributeValue(node, \"href\");\n    if (href) {\n      const fetchUrl = entryManager.url ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(entryManager.url, href) : href;\n      return loader.load({ scope: appName, url: fetchUrl }).then(({ resourceManager: styleManager }) => {\n        if (styleManager) {\n          styleManager.setDep(node);\n          styleManager == null ? void 0 : styleManager.correctPath();\n          return styleManager;\n        } else {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`${appName} Failed to load link: ${fetchUrl}`);\n        }\n      }).catch(() => null);\n    }\n  }).filter(Boolean));\n  const metaNodes = Promise.all(entryManager.findAllMetaNodes().map((node) => {\n    if (!entryManager.DOMApis.isRemoteModule(node))\n      return;\n    const async = entryManager.findAttributeValue(node, \"async\");\n    const alias = entryManager.findAttributeValue(node, \"alias\");\n    if (!isAsync(async)) {\n      const src = entryManager.findAttributeValue(node, \"src\");\n      if (src) {\n        return loader.loadModule(src).then(({ resourceManager: moduleManager }) => {\n          if (moduleManager && alias) {\n            moduleManager && moduleManager.setAlias(alias);\n          }\n          return moduleManager;\n        }).catch(() => null);\n      }\n    } else if (alias) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`Asynchronous loading module, the alias \"${alias}\" is invalid.`);\n    }\n  }).filter(Boolean));\n  return Promise.all([jsNodes, linkNodes, metaNodes]).then((ls) => ls.map((ns) => ns.filter(Boolean)));\n}\nasync function processAppResources(loader, appInfo) {\n  let isHtmlMode = false, fakeEntryManager;\n  const resources = { js: [], link: [], modules: [] };\n  (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(appInfo.entry, `[${appInfo.name}] Entry is not specified.`);\n  const { resourceManager: entryManager } = await loader.load({\n    scope: appInfo.name,\n    url: (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(location.href, appInfo.entry)\n  });\n  if (entryManager instanceof _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.TemplateManager) {\n    isHtmlMode = true;\n    const [js, link, modules] = await fetchStaticResources(appInfo.name, loader, entryManager);\n    resources.js = js;\n    resources.link = link;\n    resources.modules = modules;\n  } else if (entryManager instanceof _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.JavaScriptManager) {\n    isHtmlMode = false;\n    const mockTemplateCode = `<script src=\"${entryManager.url}\"><\\/script>`;\n    fakeEntryManager = new _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.TemplateManager(mockTemplateCode, entryManager.url);\n    entryManager.setDep(fakeEntryManager.findAllJsNodes()[0]);\n    resources.js = [entryManager];\n  } else {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.error)(`Entrance wrong type of resource of \"${appInfo.name}\".`);\n  }\n  return [fakeEntryManager || entryManager, resources, isHtmlMode];\n}\n\n// src/plugins/fixHMR.ts\nfunction GarfishHMRPlugin() {\n  let hasInit = false;\n  let isHotUpdate = false;\n  return function(Garfish2) {\n    return {\n      name: \"fix-hmr\",\n      version: \"1.13.3\",\n      bootstrap() {\n        if (hasInit)\n          return;\n        hasInit = true;\n        let webpackHotUpdateName = \"webpackHotUpdate\";\n        let webpackHotUpdate = window[webpackHotUpdateName];\n        for (const i in window) {\n          if (i.includes(\"webpackHotUpdate\")) {\n            webpackHotUpdateName = i;\n            webpackHotUpdate = window[i];\n          }\n        }\n        if (typeof webpackHotUpdate === \"function\") {\n          window[webpackHotUpdateName] = function() {\n            isHotUpdate = true;\n            return webpackHotUpdate.apply(this, arguments);\n          };\n          const observer = new MutationObserver(() => {\n            if (!isHotUpdate)\n              return;\n            isHotUpdate = false;\n            Garfish2.activeApps.forEach((app) => {\n              if (app.mounted) {\n                setTimeout(() => {\n                  app.display && app.hide();\n                  app.show();\n                });\n              }\n            });\n          });\n          observer.observe(document.documentElement, {\n            subtree: true,\n            childList: true,\n            attributes: true\n          });\n        }\n      }\n    };\n  };\n}\n\n// src/plugins/lifecycle.ts\nfunction GarfishOptionsLife(options, name) {\n  return function() {\n    return __spreadValues({\n      name,\n      version: \"1.13.3\"\n    }, options);\n  };\n}\n\n// src/plugins/preload.ts\n\n\nvar storageKey = \"__garfishPreloadApp__\";\nvar isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\nvar requestQueue = new _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.Queue();\nvar isSlowNetwork = () => navigator.connection ? navigator.connection.saveData || /(2|3)g/.test(navigator.connection.effectiveType) : false;\nvar requestIdleCallback = typeof _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.idleCallback !== \"function\" ? window.setTimeout : _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.idleCallback;\nfunction safeLoad({\n  loader,\n  appName,\n  url,\n  isModule,\n  immediately,\n  callback\n}) {\n  const generateSuccess = (next = () => {\n  }) => ({ resourceManager }) => {\n    callback && callback(resourceManager);\n    setTimeout(next, 500);\n  };\n  const generateThrowWarn = (next = () => {\n  }) => (e) => {\n    if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`Preload failed. \"${url}\"`);\n    }\n    next();\n  };\n  const loadResource = (next = () => {\n  }) => {\n    const throwWarn = generateThrowWarn(next);\n    const success = generateSuccess(next);\n    try {\n      if (isModule) {\n        loader.loadModule(url).then(success, throwWarn);\n      } else {\n        loader.load({ scope: appName, url }).then(success, throwWarn);\n      }\n    } catch (e) {\n      throwWarn(e);\n      next();\n    }\n  };\n  if (immediately) {\n    loadResource();\n  } else {\n    requestQueue.add((next) => {\n      requestIdleCallback(() => loadResource(next));\n    });\n  }\n}\nfunction loadAppResource(loader, info, immediately = false) {\n  false;\n  const fetchUrl = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(location.href, info.entry);\n  safeLoad({\n    loader,\n    appName: info.name,\n    url: fetchUrl,\n    isModule: false,\n    immediately,\n    callback: (manager) => {\n      const loadStaticResource = () => {\n        if (manager instanceof _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.TemplateManager) {\n          const baseUrl = manager.url;\n          const jsNodes = manager.findAllJsNodes();\n          const linkNodes = manager.findAllLinkNodes();\n          const metaNodes = manager.findAllMetaNodes();\n          if (jsNodes) {\n            jsNodes.forEach((node) => {\n              const src = manager.findAttributeValue(node, \"src\");\n              src && safeLoad({\n                loader,\n                appName: info.name,\n                url: baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(baseUrl, src) : src,\n                isModule: false,\n                immediately\n              });\n            });\n          }\n          if (linkNodes) {\n            linkNodes.forEach((node) => {\n              if (manager.DOMApis.isCssLinkNode(node)) {\n                const href = manager.findAttributeValue(node, \"href\");\n                href && safeLoad({\n                  loader,\n                  appName: info.name,\n                  url: baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.transformUrl)(baseUrl, href) : href,\n                  isModule: false,\n                  immediately\n                });\n              }\n            });\n          }\n          if (metaNodes) {\n            metaNodes.forEach((node) => {\n              if (manager.DOMApis.isRemoteModule(node)) {\n                const src = manager.findAttributeValue(node, \"src\");\n                if (src && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isAbsolute)(src)) {\n                  safeLoad({\n                    loader,\n                    appName: info.name,\n                    url: src,\n                    isModule: true,\n                    immediately\n                  });\n                } else {\n                  (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The loading of the remote module must be an absolute path. \"${src}\"`);\n                }\n              }\n            });\n          }\n        }\n      };\n      if (immediately) {\n        loadStaticResource();\n      } else {\n        requestIdleCallback(loadStaticResource);\n      }\n    }\n  });\n}\nfunction getRanking() {\n  const str = localStorage.getItem(storageKey);\n  if (str) {\n    const data = JSON.parse(str);\n    return data.sort((a, b) => b.count - a.count);\n  }\n  return [];\n}\nfunction setRanking(appName) {\n  const str = localStorage.getItem(storageKey);\n  const newCurrent = { appName, count: 1 };\n  if (!str) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.safeWrapper)(() => localStorage.setItem(storageKey, JSON.stringify([newCurrent])));\n  } else {\n    const data = JSON.parse(str);\n    const current = data.find((app) => app.appName === appName);\n    current ? current.count++ : data.push(newCurrent);\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.safeWrapper)(() => localStorage.setItem(storageKey, JSON.stringify(data)));\n  }\n}\nvar loadedMap = /* @__PURE__ */ Object.create(null);\nfunction GarfishPreloadPlugin() {\n  return function(Garfish2) {\n    Garfish2.preloadApp = (appName) => {\n      loadAppResource(Garfish2.loader, Garfish2.appInfos[appName], true);\n    };\n    return {\n      name: \"preload\",\n      version: \"1.13.3\",\n      beforeLoad(appInfo) {\n        if (Garfish2.options.disablePreloadApp) {\n          return;\n        }\n        setRanking(appInfo.name);\n      },\n      registerApp(appInfos) {\n        if (Garfish2.options.disablePreloadApp) {\n          return;\n        }\n        setTimeout(() => {\n          if (isMobile || isSlowNetwork())\n            return;\n          const ranking = getRanking();\n          for (const { appName } of ranking) {\n            if (appInfos[appName] && !loadedMap[appName]) {\n              loadedMap[appName] = true;\n              loadAppResource(Garfish2.loader, appInfos[appName]);\n            }\n          }\n          for (const key in appInfos) {\n            if (!loadedMap[key]) {\n              loadAppResource(Garfish2.loader, appInfos[key]);\n            }\n          }\n        },  false ? 0 : 5e3);\n      }\n    };\n  };\n}\n\n// src/plugins/performance/subAppObserver.ts\n\nvar SubAppObserver = class {\n  constructor(options) {\n    this.observer = new MutationObserver(this._mutationObserverCallback.bind(this));\n    this.subAppBeforeLoadTime = 0;\n    this.subAppBeforeMountTime = 0;\n    this.subAppStartPageShowTime = 0;\n    this.subAppPageShowTime = 0;\n    this.entry = \"\";\n    this.observeTimer = 0;\n    this.dataTimer = 0;\n    this.domQuerySelector = options.subAppRootSelector;\n    this.config = { attributes: true, childList: true, subtree: true };\n    this.targetSubscriber = [];\n    this.timeLag = options.domObserverMaxTime || 3e3;\n    this.reportTimeLag = options.waitSubAppNotifyMaxTime || 1e4;\n    this.isRecordFinish = false;\n    this.cbEntryList = [];\n    this.isStartShowFlag = true;\n    this.isCallBackFinish = false;\n    this.isSubAppNotifyFinish = false;\n    this.finishAction = \"\";\n    this.performanceData = {\n      resourceLoadTime: 0,\n      blankScreenTime: 0,\n      firstScreenTime: 0,\n      isFirstRender: true,\n      entry: \"\",\n      action: \"\"\n    };\n  }\n  subscribePerformanceData(callback) {\n    try {\n      this.targetSubscriber.push(callback);\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n  subscribePerformanceDataOnce(callback) {\n    try {\n      const wrapCallback = (performanceData) => {\n        callback(performanceData);\n        this.unsubscribePerformanceData(wrapCallback);\n      };\n      this.targetSubscriber.push(wrapCallback);\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n  unsubscribePerformanceData(callback) {\n    try {\n      this.targetSubscriber = this.targetSubscriber.filter((sub) => sub === callback);\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n  subAppBeforeLoad(entry) {\n    this.entry = entry;\n    this.isRecordFinish = false;\n    this.isSubAppNotifyFinish = false;\n    this.subAppBeforeLoadTime = performance.now();\n    this.isCallBackFinish = false;\n    this._handleSubscribeCallback(false);\n  }\n  subAppBeforeMount() {\n    this.subAppBeforeMountTime = performance.now();\n    this._subAppStartObserver();\n  }\n  subAppUnmount() {\n    if (!this.isRecordFinish) {\n      this._subAppEndObserver(\"subAppUnmount\");\n    }\n    this._handleSubscribeCallback(true);\n  }\n  afterRenderNotify() {\n    if (!this.isRecordFinish) {\n      this._subAppEndObserver(\"SubAppRenderNotify\");\n    } else if (!this.isSubAppNotifyFinish) {\n      this.isSubAppNotifyFinish = true;\n      this.isRecordFinish = true;\n      this.finishAction = \"SubAppRenderNotify\";\n      this._subAppPerformanceDataHandle();\n    }\n  }\n  _mutationObserverCallback() {\n    if (this.isStartShowFlag) {\n      this.subAppStartPageShowTime = performance.now();\n      this.isStartShowFlag = false;\n    }\n    clearTimeout(this.observeTimer);\n    this.observeTimer = setTimeout(() => {\n      clearTimeout(this.observeTimer);\n      if (!this.isRecordFinish) {\n        this._subAppEndObserver(\"MutationObserver\");\n      }\n    }, this.timeLag);\n  }\n  _subAppEndObserver(finishAction) {\n    this.isRecordFinish = true;\n    this.finishAction = finishAction;\n    this.subAppPageShowTime = performance.now();\n    this.observer.disconnect();\n    this._subAppPerformanceDataHandle();\n    this.isStartShowFlag = true;\n  }\n  async _subAppStartObserver() {\n    try {\n      const targetNode = await (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.getRenderNode)(this.domQuerySelector);\n      this.observer.observe(targetNode, this.config);\n      this._subAppClickEventObserver(targetNode);\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n  _subAppPerformanceDataHandle() {\n    const timeDifference = this.finishAction === \"MutationObserver\" ? this.timeLag : 0;\n    this.performanceData = {\n      resourceLoadTime: this.subAppBeforeMountTime - this.subAppBeforeLoadTime,\n      blankScreenTime: this.subAppStartPageShowTime - this.subAppBeforeLoadTime,\n      firstScreenTime: this.subAppPageShowTime - this.subAppBeforeLoadTime - timeDifference,\n      isFirstRender: this.cbEntryList.indexOf(this.entry) === -1,\n      entry: this.entry,\n      action: this.finishAction\n    };\n  }\n  _subAppClickEventObserver(targetNode) {\n    const eventCallback = () => {\n      clearTimeout(this.observeTimer);\n      if (!this.isRecordFinish) {\n        this._subAppEndObserver(\"UserEvent\");\n      }\n    };\n    targetNode.addEventListener(\"click\", eventCallback);\n    targetNode.addEventListener(\"keyup\", eventCallback);\n    targetNode.addEventListener(\"keydown\", eventCallback);\n    targetNode.addEventListener(\"keypress\", eventCallback);\n  }\n  _handleCallback() {\n    try {\n      this.isCallBackFinish = true;\n      this.targetSubscriber.forEach((callback) => {\n        const {\n          firstScreenTime,\n          blankScreenTime,\n          resourceLoadTime,\n          action,\n          entry\n        } = this.performanceData;\n        if (firstScreenTime > 0 && blankScreenTime > 0 && resourceLoadTime > 0 && action && entry) {\n          if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n            console.warn(\"SUCCESS: \", this.performanceData);\n          }\n          this.cbEntryList.push(this.entry);\n          callback(this.performanceData);\n        } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          console.warn(\"ERROR: \", this.performanceData);\n        }\n      });\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n  _handleSubscribeCallback(isImmediately) {\n    try {\n      clearTimeout(this.dataTimer);\n      if (isImmediately && !this.isCallBackFinish) {\n        this._handleCallback();\n      } else {\n        this.dataTimer = setTimeout(() => {\n          this._handleCallback();\n        }, this.reportTimeLag);\n      }\n    } catch (e) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n    }\n  }\n};\n\n// src/plugins/performance/index.ts\nfunction GarfishPerformance() {\n  return function() {\n    const subAppMap = {};\n    return {\n      name: \"performance\",\n      beforeLoad(appInfo) {\n        if (!subAppMap[appInfo.name] && appInfo.domGetter) {\n          subAppMap[appInfo.name] = new SubAppObserver({\n            subAppRootSelector: appInfo.domGetter\n          });\n        }\n        subAppMap[appInfo.name].subAppBeforeLoad(appInfo.entry);\n      },\n      afterLoad(appInfo, appInstance) {\n        if (appInstance) {\n          appInstance.appPerformance = subAppMap[appInfo.name];\n        }\n      },\n      beforeMount(appInfo) {\n        subAppMap[appInfo.name].subAppBeforeMount(appInfo.entry);\n      },\n      beforeUnmount(appInfo) {\n        subAppMap[appInfo.name].subAppUnmount(appInfo.entry);\n      }\n    };\n  };\n}\n\n// src/plugins/logger.ts\n\nfunction GarfishLogger() {\n  return function() {\n    return {\n      name: \"garfish-logger\",\n      version: \"1.13.3\",\n      beforeLoad(appInfo, ...args) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} beforeLoad`, [appInfo, ...args]);\n      },\n      afterLoad(appInfo, appInstance, ...args) {\n        if (appInstance) {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} id: ${appInstance.appId} afterLoad`, [\n            appInfo,\n            ...args\n          ]);\n        }\n      },\n      beforeMount(appInfo, appInstance, ...args) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} id: ${appInstance.appId} beforeMount`, [\n          appInfo,\n          ...args\n        ]);\n      },\n      afterMount(appInfo, appInstance, ...args) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} id: ${appInstance.appId} afterMount`, [\n          appInfo,\n          ...args\n        ]);\n      },\n      beforeUnmount(appInfo, appInstance, ...args) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} id: ${appInstance.appId} beforeUnmount`, [\n          appInfo,\n          ...args\n        ]);\n      },\n      afterUnmount(appInfo, appInstance, ...args) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.coreLog)(`${appInfo.name} id: ${appInstance.appId} afterUnmount`, [\n          appInfo,\n          ...args\n        ]);\n      }\n    };\n  };\n}\n\n// src/garfish.ts\nvar DEFAULT_PROPS = /* @__PURE__ */ new WeakMap();\nvar HOOKS_API = {\n  SyncHook: _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncHook,\n  AsyncHook: _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.AsyncHook,\n  SyncWaterfallHook: _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.SyncWaterfallHook,\n  AsyncWaterfallHook: _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.AsyncWaterfallHook\n};\nvar Garfish = class extends eventemitter2__WEBPACK_IMPORTED_MODULE_1__.EventEmitter2 {\n  constructor(options) {\n    super();\n    this.running = false;\n    this.version = \"1.13.3\";\n    this.flag = _garfish_utils__WEBPACK_IMPORTED_MODULE_2__.__GARFISH_FLAG__;\n    this.loader = new _garfish_loader__WEBPACK_IMPORTED_MODULE_0__.Loader();\n    this.hooks = globalLifecycle();\n    this.channel = new eventemitter2__WEBPACK_IMPORTED_MODULE_1__.EventEmitter2();\n    this.options = createDefaultOptions();\n    this.externals = {};\n    this.activeApps = [];\n    this.plugins = {};\n    this.cacheApps = {};\n    this.appInfos = {};\n    this.loading = {};\n    var _a;\n    this.setOptions(options);\n    DEFAULT_PROPS.set(this, {});\n    (_a = this.options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));\n    this.usePlugin(GarfishHMRPlugin());\n    this.usePlugin(GarfishPerformance());\n    this.usePlugin(GarfishPreloadPlugin());\n    this.usePlugin(GarfishLogger());\n  }\n  get props() {\n    return this.options && this.options.props || DEFAULT_PROPS.get(this);\n  }\n  setOptions(options) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.running, \"Garfish is running, can`t set options\");\n    if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(options)) {\n      this.options = deepMergeConfig(this.options, options);\n    }\n    return this;\n  }\n  createPluginSystem(callback) {\n    const hooks = callback(HOOKS_API);\n    return new _garfish_hooks__WEBPACK_IMPORTED_MODULE_3__.PluginSystem(hooks);\n  }\n  usePlugin(plugin, ...args) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.running, \"Cannot register plugin after Garfish is started.\");\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof plugin === \"function\", \"Plugin must be a function.\");\n    args.unshift(this);\n    const pluginConfig = plugin.apply(null, args);\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(pluginConfig.name, \"The plugin must have a name.\");\n    if (!this.plugins[pluginConfig.name]) {\n      this.plugins[pluginConfig.name] = pluginConfig;\n      this.hooks.usePlugin(pluginConfig);\n    } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(\"Please do not register the plugin repeatedly.\");\n    }\n    return this;\n  }\n  run(options = {}) {\n    var _a;\n    if (this.running) {\n      if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(\"Garfish is already running now, Cannot run Garfish repeatedly.\");\n      }\n      return this;\n    }\n    this.setOptions(options);\n    (_a = options.plugins) == null ? void 0 : _a.forEach((plugin) => this.usePlugin(plugin));\n    this.usePlugin(GarfishOptionsLife(this.options, \"global-lifecycle\"));\n    this.hooks.lifecycle.beforeBootstrap.emit(this.options);\n    this.registerApp(this.options.apps || []);\n    this.running = true;\n    this.hooks.lifecycle.bootstrap.emit(this.options);\n    return this;\n  }\n  registerApp(list) {\n    const currentAdds = {};\n    this.hooks.lifecycle.beforeRegisterApp.emit(list);\n    if (!Array.isArray(list))\n      list = [list];\n    for (const appInfo of list) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(appInfo.name, \"Miss app.name.\");\n      if (!this.appInfos[appInfo.name]) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(appInfo.entry, `${appInfo.name} application entry is not url: ${appInfo.entry}`);\n        currentAdds[appInfo.name] = appInfo;\n        this.appInfos[appInfo.name] = appInfo;\n      } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The \"${appInfo.name}\" app is already registered.`);\n      }\n    }\n    this.hooks.lifecycle.registerApp.emit(currentAdds);\n    return this;\n  }\n  setExternal(nameOrExtObj, value) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(nameOrExtObj, \"Invalid parameter.\");\n    if (typeof nameOrExtObj === \"object\") {\n      for (const key in nameOrExtObj) {\n        if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n          this.externals[key] && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`The \"${key}\" will be overwritten in external.`);\n        }\n        this.externals[key] = nameOrExtObj[key];\n      }\n    } else {\n      this.externals[nameOrExtObj] = value;\n    }\n    return this;\n  }\n  loadApp(appName, options) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(appName, \"Miss appName.\");\n    let appInfo = generateAppOptions(appName, this, options);\n    const asyncLoadProcess = async () => {\n      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);\n      if (stop === false) {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(`Load ${appName} application is terminated by beforeLoad.`);\n        return null;\n      }\n      appInfo = generateAppOptions(appName, this, options);\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.assert)(appInfo.entry, `Can't load unexpected child app \"${appName}\", Please provide the entry parameters or registered in advance of the app.`);\n      let appInstance = null;\n      const cacheApp = this.cacheApps[appName];\n      if (appInfo.cache && cacheApp) {\n        appInstance = cacheApp;\n      } else {\n        try {\n          const [manager, resources, isHtmlMode] = await processAppResources(this.loader, appInfo);\n          appInstance = new App(this, appInfo, manager, resources, isHtmlMode, appInfo.customLoader);\n          for (const key in this.plugins) {\n            appInstance.hooks.usePlugin(this.plugins[key]);\n          }\n          if (appInfo.cache) {\n            this.cacheApps[appName] = appInstance;\n          }\n        } catch (e) {\n          (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_2__.warn)(e);\n          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);\n        }\n      }\n      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);\n      return appInstance;\n    };\n    if (!this.loading[appName]) {\n      this.loading[appName] = asyncLoadProcess().finally(() => {\n        delete this.loading[appName];\n      });\n    }\n    return this.loading[appName];\n  }\n};\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+core@1.13.3/node_modules/@garfish/core/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsyncHook\": () => (/* binding */ AsyncHook),\n/* harmony export */   \"AsyncWaterfallHook\": () => (/* binding */ AsyncWaterfallHook),\n/* harmony export */   \"PluginSystem\": () => (/* binding */ PluginSystem),\n/* harmony export */   \"SyncHook\": () => (/* binding */ SyncHook),\n/* harmony export */   \"SyncWaterfallHook\": () => (/* binding */ SyncWaterfallHook)\n/* harmony export */ });\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\n// src/syncHook.ts\n\nvar SyncHook = class {\n  constructor(type) {\n    this.type = \"\";\n    this.listeners = /* @__PURE__ */ new Set();\n    if (type)\n      this.type = type;\n  }\n  on(fn) {\n    if (typeof fn === \"function\") {\n      this.listeners.add(fn);\n    } else if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('Invalid parameter in \"Hook\".');\n    }\n  }\n  once(fn) {\n    const self = this;\n    this.on(function wrapper(...args) {\n      self.remove(wrapper);\n      return fn.apply(null, args);\n    });\n  }\n  emit(...data) {\n    if (this.listeners.size > 0) {\n      this.listeners.forEach((fn) => fn.apply(null, data));\n    }\n  }\n  remove(fn) {\n    return this.listeners.delete(fn);\n  }\n  removeAll() {\n    this.listeners.clear();\n  }\n};\n\n// src/asyncHook.ts\nvar AsyncHook = class extends SyncHook {\n  emit(...data) {\n    let result;\n    const ls = Array.from(this.listeners);\n    if (ls.length > 0) {\n      let i = 0;\n      const call = (prev) => {\n        if (prev === false) {\n          return false;\n        } else if (i < ls.length) {\n          return Promise.resolve(ls[i++].apply(null, data)).then(call);\n        } else {\n          return prev;\n        }\n      };\n      result = call();\n    }\n    return Promise.resolve(result);\n  }\n};\n\n// src/syncWaterfallHook.ts\n\nfunction checkReturnData(originData, returnData) {\n  if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(returnData))\n    return false;\n  if (originData !== returnData) {\n    for (const key in originData) {\n      if (!(key in returnData)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nvar SyncWaterfallHook = class extends SyncHook {\n  constructor(type) {\n    super();\n    this.onerror = _garfish_utils__WEBPACK_IMPORTED_MODULE_0__.error;\n    this.type = type;\n  }\n  emit(data) {\n    if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(data)) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`\"${this.type}\" hook response data must be an object.`);\n    }\n    for (const fn of this.listeners) {\n      try {\n        const tempData = fn(data);\n        if (checkReturnData(data, tempData)) {\n          data = tempData;\n        } else {\n          this.onerror(`The return value of hook \"${this.type}\" is incorrect.`);\n          break;\n        }\n      } catch (e) {\n        (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(e);\n        this.onerror(e);\n      }\n    }\n    return data;\n  }\n};\n\n// src/asyncWaterfallHooks.ts\n\nvar AsyncWaterfallHook = class extends SyncHook {\n  constructor(type) {\n    super();\n    this.onerror = _garfish_utils__WEBPACK_IMPORTED_MODULE_0__.error;\n    this.type = type;\n  }\n  emit(data) {\n    if (!(0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(data)) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`\"${this.type}\" hook response data must be an object.`);\n    }\n    const ls = Array.from(this.listeners);\n    if (ls.length > 0) {\n      let i = 0;\n      const processError = (e) => {\n        (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(e);\n        this.onerror(e);\n        return data;\n      };\n      const call = (prevData) => {\n        if (prevData === false) {\n          return false;\n        } else if (checkReturnData(data, prevData)) {\n          data = prevData;\n          if (i < ls.length) {\n            try {\n              return Promise.resolve(ls[i++](data)).then(call, processError);\n            } catch (e) {\n              return processError(e);\n            }\n          }\n        } else {\n          this.onerror(`The return value of hook \"${this.type}\" is incorrect.`);\n        }\n        return data;\n      };\n      return Promise.resolve(call(data));\n    }\n    return Promise.resolve(data);\n  }\n};\n\n// src/pluginSystem.ts\n\nvar PluginSystem = class {\n  constructor(lifecycle) {\n    this.registerPlugins = {};\n    this.lifecycle = lifecycle;\n    this.lifecycleKeys = Object.keys(lifecycle);\n  }\n  usePlugin(plugin) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(plugin), \"Invalid plugin configuration.\");\n    const pluginName = plugin.name;\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(pluginName, \"Plugin must provide a name.\");\n    if (!this.registerPlugins[pluginName]) {\n      this.registerPlugins[pluginName] = plugin;\n      for (const key in this.lifecycle) {\n        const pluginLife = plugin[key];\n        if (pluginLife) {\n          this.lifecycle[key].on(pluginLife);\n        }\n      }\n    } else {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Repeat to register plugin hooks \"${pluginName}\".`);\n    }\n  }\n  removePlugin(pluginName) {\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(pluginName, \"Must provide a name.\");\n    const plugin = this.registerPlugins[pluginName];\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(plugin, `plugin \"${pluginName}\" is not registered.`);\n    for (const key in plugin) {\n      if (key === \"name\")\n        continue;\n      this.lifecycle[key].remove(plugin[key]);\n    }\n  }\n  inherit({ lifecycle, registerPlugins }) {\n    for (const hookName in lifecycle) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.lifecycle[hookName], `\"${hookName}\" hook has conflict and cannot be inherited.`);\n      this.lifecycle[hookName] = lifecycle[hookName];\n    }\n    for (const pluginName in registerPlugins) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.registerPlugins[pluginName], `\"${pluginName}\" plugin has conflict and cannot be inherited.`);\n      this.usePlugin(registerPlugins[pluginName]);\n    }\n    return this;\n  }\n};\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+loader@1.13.3/node_modules/@garfish/loader/dist/esm/index.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+loader@1.13.3/node_modules/@garfish/loader/dist/esm/index.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CrossOriginCredentials\": () => (/* binding */ CrossOriginCredentials),\n/* harmony export */   \"JavaScriptManager\": () => (/* binding */ JavaScriptManager),\n/* harmony export */   \"Loader\": () => (/* binding */ Loader),\n/* harmony export */   \"ModuleManager\": () => (/* binding */ ModuleManager),\n/* harmony export */   \"StyleManager\": () => (/* binding */ StyleManager),\n/* harmony export */   \"TemplateManager\": () => (/* binding */ TemplateManager)\n/* harmony export */ });\n/* harmony import */ var _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/hooks */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+hooks@1.13.3/node_modules/@garfish/hooks/dist/esm/index.js\");\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/index.ts\n\n\n\n// src/managers/style.ts\n\nvar MATCH_CSS_URL = /url\\(\\s*(['\"])?(.*?)\\1\\s*\\)/g;\nvar MATCH_CHARSET_URL = /@charset\\s+(['\"])(.*?)\\1\\s*;?/g;\nvar MATCH_IMPORT_URL = /@import\\s+(['\"])(.*?)\\1/g;\nvar StyleManager = class {\n  constructor(styleCode, url) {\n    this.depsStack = /* @__PURE__ */ new Set();\n    this.scopeData = null;\n    this.url = url || null;\n    this.styleCode = styleCode;\n  }\n  correctPath(baseUrl) {\n    const { url, styleCode } = this;\n    if (!baseUrl)\n      baseUrl = url;\n    if (baseUrl && typeof styleCode === \"string\") {\n      this.styleCode = styleCode.replace(MATCH_CHARSET_URL, \"\").replace(MATCH_IMPORT_URL, function(k0, k1, k2) {\n        return k2 ? `@import url(${k1}${k2}${k1})` : k0;\n      }).replace(MATCH_CSS_URL, (k0, k1, k2) => {\n        if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isAbsolute)(k2))\n          return k0;\n        return `url(\"${baseUrl ? (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.transformUrl)(baseUrl, k2) : k2}\")`;\n      });\n    }\n  }\n  transformCode(code) {\n    return code;\n  }\n  setDep(node) {\n    this.depsStack.add(node);\n  }\n  setScope(data) {\n    this.scopeData = data;\n  }\n  isSameOrigin(node) {\n    return this.depsStack.has(node);\n  }\n  renderAsStyleElement(extraCode = \"\") {\n    const node = document.createElement(\"style\");\n    const code = extraCode + (this.styleCode ? this.styleCode : \"/**empty style**/\");\n    node.setAttribute(\"type\", \"text/css\");\n    node.textContent = this.transformCode(code);\n    return node;\n  }\n  clone() {\n    const cloned = new this.constructor();\n    cloned.url = this.url;\n    cloned.styleCode = this.styleCode;\n    cloned.scopeData = this.scopeData;\n    cloned.depsStack = new Set(this.depsStack);\n    return cloned;\n  }\n};\n\n// src/managers/module.ts\nvar ModuleManager = class {\n  constructor(moduleCode, url) {\n    this.alias = null;\n    this.url = url || null;\n    this.moduleCode = moduleCode;\n  }\n  setAlias(name) {\n    if (name && typeof name === \"string\") {\n      this.alias = name;\n    }\n  }\n  clone() {\n    const cloned = new this.constructor();\n    cloned.url = this.url;\n    cloned.alias = this.alias;\n    cloned.moduleCode = this.moduleCode;\n    return cloned;\n  }\n};\n\n// src/managers/template.ts\n\nvar TemplateManager = class {\n  constructor(template, url) {\n    this.DOMApis = new _garfish_utils__WEBPACK_IMPORTED_MODULE_1__.DOMApis();\n    this.astTree = [];\n    this.pretreatmentStore = {};\n    this.url = url;\n    if (template) {\n      const [astTree, collectionEls] = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.templateParse)(template, [\n        \"meta\",\n        \"link\",\n        \"style\",\n        \"script\"\n      ]);\n      this.astTree = astTree;\n      this.pretreatmentStore = collectionEls;\n    }\n  }\n  getNodesByTagName(...tags) {\n    let counter = 0;\n    const collection = {};\n    for (const tag of tags) {\n      if (this.pretreatmentStore[tag]) {\n        counter++;\n        collection[tag] = this.pretreatmentStore[tag];\n      } else {\n        collection[tag] = [];\n      }\n    }\n    if (counter !== tags.length) {\n      const traverse = (node) => {\n        if (node.type !== \"element\")\n          return;\n        if (tags.indexOf(node.tagName) > -1 && !this.pretreatmentStore[node.tagName]) {\n          collection[node.tagName].push(node);\n        }\n        for (const child of node.children)\n          traverse(child);\n      };\n      for (const node of this.astTree)\n        traverse(node);\n    }\n    return collection;\n  }\n  createElements(renderer, parent, commonRender) {\n    const elements = [];\n    const traverse = (node, parentEl) => {\n      var _a;\n      let el;\n      if (this.DOMApis.isCommentNode(node)) {\n      } else if (this.DOMApis.isText(node)) {\n        el = this.DOMApis.createTextNode(node);\n        parentEl && parentEl.appendChild(el);\n      } else if (this.DOMApis.isNode(node)) {\n        const { tagName, children } = node;\n        if (typeof commonRender === \"function\") {\n          el = (_a = commonRender(node, parent)) == null ? void 0 : _a.customElement;\n        }\n        if (!el) {\n          if (renderer[tagName]) {\n            el = renderer[tagName](node);\n          } else {\n            el = this.DOMApis.createElement(node);\n          }\n        }\n        if (parentEl && el) {\n          parentEl.appendChild(el);\n        }\n        if (el) {\n          const { nodeType, _ignoreChildNodes } = el;\n          if (!_ignoreChildNodes && nodeType !== 8 && nodeType !== 10) {\n            for (const child of children) {\n              traverse(child, el);\n            }\n          }\n        }\n      }\n      return el;\n    };\n    for (const node of this.astTree) {\n      if (this.DOMApis.isNode(node) && node.tagName !== \"!doctype\") {\n        const el = traverse(node, parent);\n        el && elements.push(el);\n      }\n    }\n    return elements;\n  }\n  toResolveUrl(node, type, baseUrl) {\n    var _a;\n    const src = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type);\n    if (src && src.value && baseUrl) {\n      src.value = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.transformUrl)(baseUrl, src.value);\n    }\n  }\n  ignoreChildNodesCreation(node) {\n    if (node) {\n      node._ignoreChildNodes = true;\n    }\n    return node;\n  }\n  findAllMetaNodes() {\n    return this.getNodesByTagName(\"meta\").meta;\n  }\n  findAllLinkNodes() {\n    return this.getNodesByTagName(\"link\").link;\n  }\n  findAllJsNodes() {\n    return this.getNodesByTagName(\"script\").script;\n  }\n  findAttributeValue(node, type) {\n    var _a, _b;\n    return ((_b = (_a = node.attributes) == null ? void 0 : _a.find(({ key }) => key === type)) == null ? void 0 : _b.value) || void 0;\n  }\n  cloneNode(node) {\n    return (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.deepMerge)(node, {});\n  }\n  clone() {\n    const cloned = new this.constructor();\n    cloned.url = this.url;\n    cloned.astTree = this.astTree;\n    cloned.pretreatmentStore = this.pretreatmentStore;\n    cloned.DOMApis = new _garfish_utils__WEBPACK_IMPORTED_MODULE_1__.DOMApis(this.DOMApis.document);\n    return cloned;\n  }\n};\n\n// src/managers/javascript.ts\nvar JavaScriptManager = class {\n  constructor(scriptCode, url) {\n    this.depsStack = /* @__PURE__ */ new Set();\n    this.mimeType = \"\";\n    this.async = false;\n    this.url = url;\n    this.scriptCode = scriptCode;\n  }\n  isModule() {\n    return this.mimeType === \"module\";\n  }\n  isInlineScript() {\n    return Boolean(!this.url);\n  }\n  setMimeType(mimeType) {\n    this.mimeType = mimeType || \"\";\n  }\n  setAsyncAttribute(val) {\n    this.async = Boolean(val);\n  }\n  setDep(node) {\n    this.depsStack.add(node);\n  }\n  isSameOrigin(node) {\n    return this.depsStack.has(node);\n  }\n  clone() {\n    const cloned = new this.constructor();\n    cloned.url = this.url;\n    cloned.async = this.async;\n    cloned.mimeType = this.mimeType;\n    cloned.scriptCode = this.scriptCode;\n    cloned.depsStack = new Set(this.depsStack);\n    return cloned;\n  }\n};\n\n// src/utils.ts\n\nfunction getRequest(customFetch) {\n  return async function request(url, config) {\n    let result = await customFetch.emit(url, config || {});\n    if (!result || !(result instanceof Response)) {\n      result = await fetch(url, config || {});\n    }\n    if (result.status >= 400) {\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.error)(`\"${url}\" load failed with status \"${result.status}\"`);\n    }\n    const code = await result.text();\n    const type = result.headers.get(\"content-type\") || \"\";\n    const size = Number(result.headers.get(\"content-size\"));\n    const mimeType = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(type || \"\");\n    return {\n      code,\n      result,\n      mimeType,\n      type,\n      size: Number.isNaN(size) ? null : size\n    };\n  };\n}\nfunction copyResult(result) {\n  if (result.resourceManager) {\n    result.resourceManager = result.resourceManager.clone();\n  }\n  return result;\n}\nfunction mergeConfig(loader, url) {\n  const extra = loader.requestConfig;\n  const config = typeof extra === \"function\" ? extra(url) : extra;\n  return __spreadValues({ mode: \"cors\" }, config);\n}\n\n// src/appCache.ts\nvar cachedDataSet = /* @__PURE__ */ new WeakSet();\nvar MAX_SIZE = 1024 * 1024 * 50;\nvar DEFAULT_POLL = Symbol(\"__defaultBufferPoll__\");\nvar FILE_TYPES = [\n  \"js\" /* js */,\n  \"css\" /* css */,\n  \"module\" /* module */,\n  \"template\" /* template */,\n  DEFAULT_POLL\n];\nvar AppCacheContainer = class {\n  constructor(maxSize = MAX_SIZE) {\n    this.totalSize = 0;\n    this.recorder = {};\n    this.maxSize = maxSize;\n    FILE_TYPES.forEach((key) => {\n      this.recorder[key] = 0;\n      this[key] = /* @__PURE__ */ new Map();\n    });\n  }\n  bufferPool(type) {\n    return this[type];\n  }\n  has(url) {\n    return FILE_TYPES.some((key) => this[key].has(url));\n  }\n  get(url) {\n    for (const key of FILE_TYPES) {\n      if (this[key].has(url)) {\n        return this[key].get(url);\n      }\n    }\n  }\n  set(url, data, type) {\n    const curSize = cachedDataSet.has(data) ? 0 : data.size;\n    const totalSize = this.totalSize + curSize;\n    if (totalSize < this.maxSize) {\n      let bar = type;\n      let bufferPool = this.bufferPool(type);\n      if (!bufferPool) {\n        bar = DEFAULT_POLL;\n        bufferPool = this.bufferPool(DEFAULT_POLL);\n      }\n      bufferPool.set(url, data);\n      this.totalSize = totalSize;\n      this.recorder[bar] += curSize;\n      return true;\n    }\n    return false;\n  }\n  clear(type) {\n    if (typeof type === \"string\") {\n      const cacheBox = this.bufferPool(type);\n      if (cacheBox && cacheBox instanceof Map) {\n        const size = this.recorder[type];\n        this.totalSize -= size;\n        this.recorder[type] = 0;\n        cacheBox.clear();\n      }\n    } else {\n      FILE_TYPES.forEach((key) => {\n        this[key].clear();\n        this.recorder[key] = 0;\n      });\n      this.totalSize = 0;\n    }\n  }\n};\n\n// src/index.ts\nvar CrossOriginCredentials = /* @__PURE__ */ ((CrossOriginCredentials2) => {\n  CrossOriginCredentials2[\"anonymous\"] = \"same-origin\";\n  CrossOriginCredentials2[\"use-credentials\"] = \"include\";\n  return CrossOriginCredentials2;\n})(CrossOriginCredentials || {});\nvar Loader = class {\n  constructor(options) {\n    this.personalId = _garfish_utils__WEBPACK_IMPORTED_MODULE_1__.__LOADER_FLAG__;\n    this.StyleManager = StyleManager;\n    this.ModuleManager = ModuleManager;\n    this.TemplateManager = TemplateManager;\n    this.JavaScriptManager = JavaScriptManager;\n    this.hooks = new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.PluginSystem({\n      error: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.SyncHook(),\n      loaded: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.SyncWaterfallHook(\"loaded\"),\n      clear: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.SyncWaterfallHook(\"clear\"),\n      beforeLoad: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.SyncWaterfallHook(\"beforeLoad\"),\n      fetch: new _garfish_hooks__WEBPACK_IMPORTED_MODULE_0__.AsyncHook(\"fetch\")\n    });\n    this.options = options || {};\n    this.loadingList = /* @__PURE__ */ Object.create(null);\n    this.cacheStore = /* @__PURE__ */ Object.create(null);\n  }\n  setOptions(options) {\n    this.options = __spreadValues(__spreadValues({}, this.options), options);\n  }\n  clear(scope, fileType) {\n    const appCacheContainer = this.cacheStore[scope];\n    if (appCacheContainer) {\n      appCacheContainer.clear(fileType);\n      this.hooks.lifecycle.clear.emit({ scope, fileType });\n    }\n  }\n  clearAll(fileType) {\n    for (const scope in this.cacheStore) {\n      this.clear(scope, fileType);\n    }\n  }\n  usePlugin(options) {\n    this.hooks.usePlugin(options);\n  }\n  setLifeCycle(lifeCycle) {\n    this.hooks.usePlugin(__spreadValues({\n      name: \"loader-lifecycle\"\n    }, lifeCycle));\n  }\n  loadModule(url) {\n    return this.load({\n      scope: \"modules\",\n      url,\n      isRemoteModule: true\n    });\n  }\n  async load({\n    scope,\n    url,\n    isRemoteModule = false,\n    crossOrigin = \"anonymous\",\n    defaultContentType = \"\"\n  }) {\n    const { options, loadingList, cacheStore } = this;\n    const res = loadingList[url];\n    if (res) {\n      return res;\n    }\n    let appCacheContainer = cacheStore[scope];\n    if (!appCacheContainer) {\n      appCacheContainer = cacheStore[scope] = new AppCacheContainer(options.maxSize);\n    }\n    if (appCacheContainer.has(url)) {\n      return Promise.resolve(copyResult(appCacheContainer.get(url)));\n    } else {\n      for (const key in cacheStore) {\n        const container = cacheStore[key];\n        if (container !== appCacheContainer) {\n          if (container.has(url)) {\n            const result = container.get(url);\n            cachedDataSet.add(result);\n            appCacheContainer.set(url, result, result.fileType);\n            return Promise.resolve(copyResult(result));\n          }\n        }\n      }\n    }\n    const requestConfig = mergeConfig(this, url);\n    requestConfig.credentials = CrossOriginCredentials[crossOrigin];\n    const resOpts = this.hooks.lifecycle.beforeLoad.emit({\n      url,\n      scope,\n      requestConfig\n    });\n    const request = getRequest(this.hooks.lifecycle.fetch);\n    const loadRes = request(resOpts.url, resOpts.requestConfig).then(({ code, size, result, type }) => {\n      let managerCtor, fileType = \"\";\n      if (isRemoteModule) {\n        fileType = \"module\" /* module */;\n        managerCtor = ModuleManager;\n      } else if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isHtmlType)({ type, src: result.url }) || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isHtmlType)({\n        type: defaultContentType\n      })) {\n        fileType = \"template\" /* template */;\n        managerCtor = TemplateManager;\n      } else if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isJsType)({ type: defaultContentType }) || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isJsType)({ type, src: result.url })) {\n        fileType = \"js\" /* js */;\n        managerCtor = JavaScriptManager;\n      } else if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isCssType)({ src: result.url, type }) || (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.isCssType)({\n        type: defaultContentType\n      })) {\n        fileType = \"css\" /* css */;\n        managerCtor = StyleManager;\n      }\n      const resourceManager = managerCtor ? new managerCtor(code, result.url) : null;\n      const data = this.hooks.lifecycle.loaded.emit({\n        result,\n        value: {\n          url,\n          scope,\n          resourceManager,\n          fileType: fileType || \"\",\n          size: size || code.length,\n          code: resourceManager ? \"\" : code\n        }\n      });\n      fileType && appCacheContainer.set(url, data.value, fileType);\n      return copyResult(data.value);\n    }).catch((e) => {\n      (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_1__.error)(e);\n      this.hooks.lifecycle.error.emit(e, { scope });\n      throw e;\n    }).finally(() => {\n      loadingList[url] = null;\n    });\n    loadingList[url] = loadRes;\n    return loadRes;\n  }\n};\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+loader@1.13.3/node_modules/@garfish/loader/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+router@1.13.3/node_modules/@garfish/router/dist/esm/index.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+router@1.13.3/node_modules/@garfish/router/dist/esm/index.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GarfishRouter\": () => (/* binding */ GarfishRouter)\n/* harmony export */ });\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/index.ts\n\n\n// src/config.ts\nvar __GARFISH_ROUTER_UPDATE_FLAG__ = \"__GARFISH_ROUTER_UPDATE_FLAG__\";\nvar __GARFISH_ROUTER_FLAG__ = \"__GARFISH_ROUTER_FLAG__\";\nvar __GARFISH_BEFORE_ROUTER_EVENT__ = \"garfish:before-routing-event\";\nvar RouterConfig = {\n  basename: \"/\",\n  current: {\n    fullPath: \"/\",\n    path: \"/\",\n    matched: [],\n    query: {},\n    state: {},\n    href: \"\"\n  },\n  apps: [],\n  beforeEach: (to, from, next) => next(),\n  afterEach: (to, from, next) => next(),\n  active: () => Promise.resolve(),\n  deactive: () => Promise.resolve(),\n  routerChange: () => {\n  },\n  autoRefreshApp: true,\n  listening: true\n};\nfunction set(field, value) {\n  RouterConfig[field] = value;\n}\nfunction setRouterConfig(options) {\n  Object.assign(RouterConfig, options);\n}\n\n// src/utils/urlUt.ts\nfunction parseQuery(query = \"\") {\n  const res = {};\n  if (query) {\n    query.slice(1).split(\"&\").map((item) => {\n      const pairs = item.split(\"=\");\n      res[pairs[0]] = pairs;\n    });\n  }\n  return res;\n}\nfunction getPath(basename = \"/\", pathname) {\n  if (basename === \"/\" || basename === \"\") {\n    return pathname || location.pathname;\n  } else {\n    return (pathname || location.pathname).replace(new RegExp(`^/?${basename}`), \"\");\n  }\n}\nfunction getAppRootPath(appInfo) {\n  const path = getPath(appInfo.basename, location.pathname);\n  let appRootPath = appInfo.basename === \"/\" ? \"\" : appInfo.basename || \"\";\n  if (typeof appInfo.activeWhen === \"string\") {\n    appRootPath += appInfo.activeWhen;\n  } else {\n    appRootPath += path.split(\"\").reduce((pre, next) => {\n      if (typeof appInfo.activeWhen === \"function\" && !appInfo.activeWhen(pre))\n        return pre + next;\n      return pre;\n    }, \"\");\n  }\n  return appRootPath;\n}\n\n// src/utils/index.ts\nasync function asyncForEach(arr, callback) {\n  const length = arr.length;\n  let k = 0;\n  while (k < length) {\n    const kValue = arr[k];\n    await callback(kValue, k, arr);\n    k++;\n  }\n}\nfunction toMiddleWare(to, from, cb) {\n  return new Promise((resolve, reject) => {\n    try {\n      cb(to, from, resolve);\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\nfunction createEvent(type) {\n  let e;\n  if (navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.appVersion.indexOf(\"Trident/\") > 0) {\n    e = document.createEvent(\"UIEvents\");\n    e.initUIEvent(type.toLowerCase(), true, false, window, 0);\n  } else {\n    e = new Event(type.toLowerCase());\n  }\n  return e;\n}\n\n// src/utils/customEvent.ts\nvar NativeCustomEvent = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g == null ? void 0 : __webpack_require__.g.CustomEvent : null;\nfunction useNative() {\n  try {\n    const p = new NativeCustomEvent(\"cat\", { detail: { foo: \"bar\" } });\n    return p.type === \"cat\" && p.detail.foo === \"bar\";\n  } catch (e) {\n  }\n  return false;\n}\nvar CustomEvent;\nif (NativeCustomEvent && useNative()) {\n  CustomEvent = NativeCustomEvent;\n} else if (typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\n  CustomEvent = function(type, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    const evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(type, params.bubbles || false, params.cancelable || false, params.detail || null);\n    return evt;\n  };\n} else {\n  CustomEvent = function(type, params) {\n    const e = document.createEventObject();\n    e.type = type;\n    if (params) {\n      e.bubbles = Boolean(params.bubbles);\n      e.cancelable = Boolean(params.cancelable);\n      e.detail = params.detail;\n    } else {\n      e.bubbles = false;\n      e.cancelable = false;\n      e.detail = void 0;\n    }\n    return e;\n  };\n}\nvar customEvent_default = CustomEvent;\n\n// src/utils/navEvent.ts\n\nfunction createPopStateEvent(state, originalMethodName) {\n  let evt;\n  try {\n    evt = new PopStateEvent(\"popstate\", { state });\n  } catch (err) {\n    evt = document.createEvent(\"PopStateEvent\");\n    evt.initPopStateEvent(\"popstate\", false, false, state);\n  }\n  evt.garfish = true;\n  evt.garfishTrigger = originalMethodName;\n  return evt;\n}\nvar callCapturedEventListeners = (type) => {\n  const eventArguments = createPopStateEvent(window.history.state, type);\n  window.dispatchEvent(eventArguments);\n};\nvar handlerParams = function(path, query, basename) {\n  if (!path || typeof path !== \"string\")\n    return \"\";\n  let url = path;\n  if (url[0] !== \"/\")\n    url = \"/\" + url;\n  if (Object.prototype.toString.call(query) === \"[object Object]\") {\n    const qs = Object.keys(query).map((key) => `${key}=${query[key]}`).join(\"&\");\n    url += qs ? \"?\" + qs : \"\";\n  }\n  if (basename !== \"/\")\n    url = basename + url;\n  if (url[0] !== \"/\")\n    url = \"/\" + url;\n  return url;\n};\nvar push = ({\n  path,\n  query,\n  basename\n}) => {\n  if (!basename)\n    basename = RouterConfig.basename || \"/\";\n  let url = null;\n  if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.validURL)(path)) {\n    url = /(^https?:)|(^\\/\\/)/.test(path) ? path : `//${path}`;\n  } else {\n    url = handlerParams(path, query, basename);\n  }\n  history.pushState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), \"\", url);\n};\nvar replace = ({\n  path,\n  query,\n  basename\n}) => {\n  if (!basename)\n    basename = RouterConfig.basename || \"/\";\n  let url = null;\n  if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.validURL)(path)) {\n    url = /^(https?:)(\\/\\/)/.test(path) ? path : `//${path}`;\n  } else {\n    url = handlerParams(path, query, basename);\n  }\n  history.replaceState(__spreadValues({ [__GARFISH_ROUTER_UPDATE_FLAG__]: true }, history.state), \"\", url);\n};\n\n// src/linkTo.ts\nvar hasActive = (activeWhen, path) => {\n  if (typeof activeWhen === \"string\") {\n    if (activeWhen[0] !== \"/\")\n      activeWhen = `/${activeWhen}`;\n    if (activeWhen === \"/\" && path === activeWhen)\n      return true;\n    const activeWhenArr = activeWhen.split(\"/\");\n    const pathArr = path.split(\"/\");\n    let flag = true;\n    activeWhenArr.forEach((pathItem, index) => {\n      if (pathItem && pathItem !== pathArr[index]) {\n        flag = false;\n      }\n    });\n    return flag;\n  } else {\n    return activeWhen(path);\n  }\n};\nvar linkTo = async ({\n  toRouterInfo,\n  fromRouterInfo,\n  eventType\n}) => {\n  const {\n    current,\n    apps,\n    deactive,\n    active,\n    notMatch,\n    beforeEach: beforeEach2,\n    afterEach: afterEach2,\n    autoRefreshApp\n  } = RouterConfig;\n  const deactiveApps = current.matched.filter((appInfo) => !hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname)));\n  const activeApps = apps.filter((appInfo) => {\n    return hasActive(appInfo.activeWhen, getPath(appInfo.basename, location.pathname));\n  });\n  const needToActive = activeApps.filter(({ name }) => {\n    return !current.matched.some(({ name: cName }) => name === cName);\n  });\n  const to = __spreadProps(__spreadValues({}, toRouterInfo), {\n    matched: needToActive\n  });\n  const from = __spreadProps(__spreadValues({}, fromRouterInfo), {\n    matched: deactiveApps\n  });\n  await toMiddleWare(to, from, beforeEach2);\n  if (current.matched.length > 0) {\n    await asyncForEach(deactiveApps, async (appInfo) => await deactive(appInfo, getPath(appInfo.basename, location.pathname)));\n  }\n  setRouterConfig({\n    current: {\n      path: getPath(RouterConfig.basename),\n      fullPath: location.pathname,\n      href: location.href,\n      matched: activeApps,\n      state: history.state,\n      query: parseQuery(location.search)\n    }\n  });\n  const curState = window.history.state || {};\n  if (eventType !== \"popstate\" && (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)) {\n    callCapturedEventListeners(eventType);\n  }\n  await asyncForEach(needToActive, async (appInfo) => {\n    const appRootPath = getAppRootPath(appInfo);\n    await active(appInfo, appRootPath);\n  });\n  if (activeApps.length === 0 && notMatch)\n    notMatch(location.pathname);\n  await toMiddleWare(to, from, afterEach2);\n};\n\n// src/agentRouter.ts\nvar normalAgent = () => {\n  const addRouterListener = function() {\n    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function(env) {\n      RouterConfig.routerChange && RouterConfig.routerChange(location.pathname);\n      linkTo(env.detail);\n    });\n  };\n  if (!window[__GARFISH_ROUTER_FLAG__]) {\n    const rewrite = function(type) {\n      const hapi = history[type];\n      return function() {\n        const urlBefore = window.location.pathname + window.location.hash;\n        const stateBefore = history == null ? void 0 : history.state;\n        const res = hapi.apply(this, arguments);\n        const urlAfter = window.location.pathname + window.location.hash;\n        const stateAfter = history == null ? void 0 : history.state;\n        const e = createEvent(type);\n        e.arguments = arguments;\n        if (urlBefore !== urlAfter || JSON.stringify(stateBefore) !== JSON.stringify(stateAfter)) {\n          window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {\n            detail: {\n              toRouterInfo: {\n                fullPath: urlAfter,\n                href: location.href,\n                query: parseQuery(location.search),\n                path: getPath(RouterConfig.basename, urlAfter),\n                state: stateAfter\n              },\n              fromRouterInfo: {\n                fullPath: urlBefore,\n                query: RouterConfig.current.query,\n                href: RouterConfig.current.href,\n                path: getPath(RouterConfig.basename, urlBefore),\n                state: stateBefore\n              },\n              eventType: type\n            }\n          }));\n        }\n        return res;\n      };\n    };\n    history.pushState = rewrite(\"pushState\");\n    history.replaceState = rewrite(\"replaceState\");\n    window.addEventListener(\"popstate\", function(event) {\n      if (event && typeof event === \"object\" && event.garfish)\n        return;\n      if (history.state && typeof history.state === \"object\")\n        delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];\n      window.dispatchEvent(new customEvent_default(__GARFISH_BEFORE_ROUTER_EVENT__, {\n        detail: {\n          toRouterInfo: {\n            fullPath: location.pathname,\n            href: location.href,\n            query: parseQuery(location.search),\n            path: getPath(RouterConfig.basename)\n          },\n          fromRouterInfo: {\n            fullPath: RouterConfig.current.fullPath,\n            path: getPath(RouterConfig.basename, RouterConfig.current.path),\n            href: RouterConfig.current.href,\n            query: RouterConfig.current.query\n          },\n          eventType: \"popstate\"\n        }\n      }));\n    }, false);\n    window[__GARFISH_ROUTER_FLAG__] = true;\n  }\n  addRouterListener();\n};\nvar initRedirect = () => {\n  linkTo({\n    toRouterInfo: {\n      fullPath: location.pathname,\n      href: location.href,\n      path: getPath(RouterConfig.basename),\n      query: parseQuery(location.search),\n      state: history.state\n    },\n    fromRouterInfo: {\n      fullPath: \"/\",\n      href: \"\",\n      path: \"/\",\n      query: {},\n      state: {}\n    },\n    eventType: \"pushState\"\n  });\n};\nvar listen = () => {\n  normalAgent();\n  initRedirect();\n};\n\n// src/context.ts\nvar beforeEach = (hook) => {\n  set(\"beforeEach\", hook);\n};\nvar afterEach = (hook) => {\n  set(\"afterEach\", hook);\n};\nvar routerChange = (hook) => {\n  set(\"routerChange\", hook);\n};\nvar registerRouter = (Apps) => {\n  const unregisterApps = Apps.filter((app) => !RouterConfig.apps.some((item) => app.name === item.name));\n  set(\"apps\", RouterConfig.apps.concat(unregisterApps));\n};\nvar listenRouterAndReDirect = ({\n  apps,\n  basename = \"/\",\n  autoRefreshApp,\n  active,\n  deactive,\n  notMatch,\n  listening = true\n}) => {\n  registerRouter(apps);\n  setRouterConfig({\n    basename,\n    autoRefreshApp,\n    active,\n    deactive,\n    notMatch,\n    listening\n  });\n  listen();\n};\nvar Router = {\n  push,\n  replace,\n  beforeEach,\n  afterEach,\n  registerRouter,\n  routerChange,\n  listenRouterAndReDirect,\n  setRouterConfig,\n  routerConfig: RouterConfig\n};\nvar context_default = Router;\n\n// src/index.ts\nfunction GarfishRouter(_args) {\n  return function(Garfish) {\n    Garfish.apps = {};\n    Garfish.router = context_default;\n    return {\n      name: \"router\",\n      version: \"1.13.3\",\n      bootstrap(options) {\n        let activeApp = null;\n        const unmounts = {};\n        const { basename } = options;\n        const { autoRefreshApp = true, onNotMatchRouter = () => null } = Garfish.options;\n        async function active(appInfo, rootPath = \"/\") {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.routerLog)(`${appInfo.name} active`, {\n            appInfo,\n            rootPath,\n            listening: RouterConfig.listening\n          });\n          if (!RouterConfig.listening)\n            return;\n          const { name, active: active2, cache = true } = appInfo;\n          if (active2)\n            return active2(appInfo, rootPath);\n          appInfo.rootPath = rootPath;\n          const currentApp = activeApp = (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.createKey)();\n          const app = await Garfish.loadApp(appInfo.name, {\n            cache,\n            basename: rootPath,\n            entry: appInfo.entry,\n            domGetter: appInfo.domGetter\n          });\n          if (app) {\n            app.appInfo.basename = rootPath;\n            const call = async (app2, isRender) => {\n              if (!app2)\n                return;\n              const isDes = cache && app2.mounted;\n              if (isRender) {\n                return await app2[isDes ? \"show\" : \"mount\"]();\n              } else {\n                return app2[isDes ? \"hide\" : \"unmount\"]();\n              }\n            };\n            Garfish.apps[name] = app;\n            unmounts[name] = () => {\n              if (app.mounting) {\n                delete Garfish.cacheApps[name];\n              }\n              call(app, false);\n            };\n            if (currentApp === activeApp) {\n              await call(app, true);\n            }\n          }\n        }\n        async function deactive(appInfo, rootPath) {\n          (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.routerLog)(`${appInfo.name} deactive`, {\n            appInfo,\n            rootPath\n          });\n          activeApp = null;\n          const { name, deactive: deactive2 } = appInfo;\n          if (deactive2)\n            return deactive2(appInfo, rootPath);\n          const unmount = unmounts[name];\n          unmount && unmount();\n          delete Garfish.apps[name];\n          const needToDeleteApps = context_default.routerConfig.apps.filter((app) => {\n            if (appInfo.rootPath === app.basename)\n              return true;\n          });\n          if (needToDeleteApps.length > 0) {\n            needToDeleteApps.forEach((app) => {\n              delete Garfish.appInfos[app.name];\n              delete Garfish.cacheApps[app.name];\n            });\n            context_default.setRouterConfig({\n              apps: context_default.routerConfig.apps.filter((app) => {\n                return !needToDeleteApps.some((needDelete) => app.name === needDelete.name);\n              })\n            });\n          }\n        }\n        const apps = Object.values(Garfish.appInfos);\n        const appList = apps.filter((app) => {\n          if (!app.basename)\n            app.basename = basename;\n          return !!app.activeWhen;\n        });\n        const listenOptions = {\n          basename,\n          active,\n          deactive,\n          autoRefreshApp,\n          notMatch: onNotMatchRouter,\n          apps: appList,\n          listening: true\n        };\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.routerLog)(\"listenRouterAndReDirect\", listenOptions);\n        listenRouterAndReDirect(listenOptions);\n      },\n      registerApp(appInfos) {\n        const appList = Object.values(appInfos);\n        context_default.registerRouter(appList.filter((app) => !!app.activeWhen));\n        if (!Garfish.running)\n          return;\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_0__.routerLog)(\"registerApp initRedirect\", appInfos);\n        initRedirect();\n      }\n    };\n  };\n}\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+router@1.13.3/node_modules/@garfish/router/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOMApis\": () => (/* binding */ DOMApis),\n/* harmony export */   \"Lock\": () => (/* binding */ Lock),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"__GARFISH_FLAG__\": () => (/* binding */ __GARFISH_FLAG__),\n/* harmony export */   \"__LOADER_FLAG__\": () => (/* binding */ __LOADER_FLAG__),\n/* harmony export */   \"__MockBody__\": () => (/* binding */ __MockBody__),\n/* harmony export */   \"__MockHead__\": () => (/* binding */ __MockHead__),\n/* harmony export */   \"__MockHtml__\": () => (/* binding */ __MockHtml__),\n/* harmony export */   \"__REMOVE_NODE__\": () => (/* binding */ __REMOVE_NODE__),\n/* harmony export */   \"_extends\": () => (/* binding */ _extends),\n/* harmony export */   \"appContainerId\": () => (/* binding */ appContainerId),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"callTestCallback\": () => (/* binding */ callTestCallback),\n/* harmony export */   \"computeErrorUrl\": () => (/* binding */ computeErrorUrl),\n/* harmony export */   \"computeStackTraceFromStackProp\": () => (/* binding */ computeStackTraceFromStackProp),\n/* harmony export */   \"coreLog\": () => (/* binding */ coreLog),\n/* harmony export */   \"createAppContainer\": () => (/* binding */ createAppContainer),\n/* harmony export */   \"createKey\": () => (/* binding */ createKey),\n/* harmony export */   \"createSourcemap\": () => (/* binding */ createSourcemap),\n/* harmony export */   \"deepMerge\": () => (/* binding */ deepMerge),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"error\": () => (/* binding */ error),\n/* harmony export */   \"evalWithEnv\": () => (/* binding */ evalWithEnv),\n/* harmony export */   \"filterAndWrapEventListener\": () => (/* binding */ filterAndWrapEventListener),\n/* harmony export */   \"filterUndefinedVal\": () => (/* binding */ filterUndefinedVal),\n/* harmony export */   \"findTarget\": () => (/* binding */ findTarget),\n/* harmony export */   \"getGarfishDebugInstanceName\": () => (/* binding */ getGarfishDebugInstanceName),\n/* harmony export */   \"getParameterByName\": () => (/* binding */ getParameterByName),\n/* harmony export */   \"getRenderNode\": () => (/* binding */ getRenderNode),\n/* harmony export */   \"getType\": () => (/* binding */ getType),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"haveSourcemap\": () => (/* binding */ haveSourcemap),\n/* harmony export */   \"hookObjectProperty\": () => (/* binding */ hookObjectProperty),\n/* harmony export */   \"idleCallback\": () => (/* binding */ idleCallback),\n/* harmony export */   \"inBrowser\": () => (/* binding */ inBrowser),\n/* harmony export */   \"internFunc\": () => (/* binding */ internFunc),\n/* harmony export */   \"isAbsolute\": () => (/* binding */ isAbsolute),\n/* harmony export */   \"isCss\": () => (/* binding */ isCss),\n/* harmony export */   \"isCssType\": () => (/* binding */ isCssType),\n/* harmony export */   \"isGarfishConfigType\": () => (/* binding */ isGarfishConfigType),\n/* harmony export */   \"isHtml\": () => (/* binding */ isHtml),\n/* harmony export */   \"isHtmlType\": () => (/* binding */ isHtmlType),\n/* harmony export */   \"isJs\": () => (/* binding */ isJs),\n/* harmony export */   \"isJsType\": () => (/* binding */ isJsType),\n/* harmony export */   \"isJsonp\": () => (/* binding */ isJsonp),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPrimitive\": () => (/* binding */ isPrimitive),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"makeMapObject\": () => (/* binding */ makeMapObject),\n/* harmony export */   \"mapObject\": () => (/* binding */ mapObject),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"noop\": () => (/* binding */ noop),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseContentType\": () => (/* binding */ parseContentType),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"routerLog\": () => (/* binding */ routerLog),\n/* harmony export */   \"safari13Deal\": () => (/* binding */ safari13Deal),\n/* harmony export */   \"safeWrapper\": () => (/* binding */ safeWrapper),\n/* harmony export */   \"setDocCurrentScript\": () => (/* binding */ setDocCurrentScript),\n/* harmony export */   \"sourceListTags\": () => (/* binding */ sourceListTags),\n/* harmony export */   \"sourceNode\": () => (/* binding */ sourceNode),\n/* harmony export */   \"supportWasm\": () => (/* binding */ supportWasm),\n/* harmony export */   \"templateParse\": () => (/* binding */ templateParse),\n/* harmony export */   \"toBase64\": () => (/* binding */ toBase64),\n/* harmony export */   \"toBoolean\": () => (/* binding */ toBoolean),\n/* harmony export */   \"toWsProtocol\": () => (/* binding */ toWsProtocol),\n/* harmony export */   \"transformUrl\": () => (/* binding */ transformUrl),\n/* harmony export */   \"unique\": () => (/* binding */ unique),\n/* harmony export */   \"validURL\": () => (/* binding */ validURL),\n/* harmony export */   \"warn\": () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n// src/utils.ts\nvar noop = () => {\n};\nvar objectToString = Object.prototype.toString;\nvar supportWasm = typeof WebAssembly === \"object\";\nvar idleCallback = window.requestIdleCallback || window.requestAnimationFrame;\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\nfunction isObject(val) {\n  return val && typeof val === \"object\";\n}\nfunction isPlainObject(val) {\n  return objectToString.call(val) === \"[object Object]\";\n}\nfunction getType(val) {\n  return objectToString.call(val).slice(8, -1).toLowerCase();\n}\nfunction isPromise(obj) {\n  return isObject(obj) && typeof obj.then === \"function\";\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nfunction def(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    get: () => value,\n    set: (val) => {\n      if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        if (val !== value) {\n          error(`Try to modify a read-only property ${key}`);\n        }\n      }\n    },\n    configurable: (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) ? true : false\n  });\n}\nfunction makeMap(list) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return (val) => !!map[val];\n}\nfunction makeMapObject(list) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return map;\n}\nfunction inBrowser() {\n  return typeof window !== \"undefined\";\n}\nvar warnPrefix = \"[Garfish warning]\";\nvar processError = (error2, fn) => {\n  try {\n    if (typeof error2 === \"string\") {\n      error2 = `${warnPrefix}: ${error2}\n\n`;\n      fn(error2, true);\n    } else if (error2 instanceof Error) {\n      if (!error2.message.startsWith(warnPrefix)) {\n        error2.message = `${warnPrefix}: ${error2.message}`;\n      }\n      fn(error2, false);\n    }\n  } catch (e) {\n    fn(error2, typeof error2 === \"string\");\n  }\n};\nfunction warn(msg) {\n  processError(msg, (e, isString) => {\n    const warnMsg = isString ? e : e.message;\n    if (false) {}\n    console.warn(warnMsg);\n  });\n}\nfunction error(error2) {\n  processError(error2, (e, isString) => {\n    if (isString) {\n      throw new Error(e);\n    } else {\n      throw e;\n    }\n  });\n}\nfunction validURL(str) {\n  const pattern = new RegExp(\"^(https?:\\\\/\\\\/)?((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*(\\\\?[;&a-z\\\\d%_.~+=-]*)?(\\\\#[-a-z\\\\d_]*)?$\", \"i\");\n  return !!pattern.test(str);\n}\nfunction internFunc(internalizeString) {\n  const temporaryOb = {};\n  temporaryOb[internalizeString] = true;\n  return Object.keys(temporaryOb)[0];\n}\nfunction evalWithEnv(code, params, context, useStrict = false) {\n  const keys = Object.keys(params);\n  const nativeWindow = (0, eval)(\"window;\");\n  const randomValKey = \"__garfish__exec_temporary__\";\n  const values = keys.map((k) => `window.${randomValKey}.${k}`);\n  const contextKey = \"__garfish_exec_temporary_context__\";\n  try {\n    nativeWindow[randomValKey] = params;\n    nativeWindow[contextKey] = context;\n    const evalInfo = [\n      `;(function(${keys.join(\",\")}){${useStrict ? '\"use strict\";' : \"\"}`,\n      `\n}).call(window.${contextKey},${values.join(\",\")});`\n    ];\n    const internalizeString = internFunc(evalInfo[0] + code + evalInfo[1]);\n    (0, eval)(internalizeString);\n  } catch (e) {\n    throw e;\n  } finally {\n    delete nativeWindow[randomValKey];\n    delete nativeWindow[contextKey];\n  }\n}\nfunction safeWrapper(callback, disableWarn) {\n  try {\n    callback();\n  } catch (e) {\n    !disableWarn && (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) && warn(e);\n  }\n}\nfunction nextTick(cb) {\n  Promise.resolve().then(cb);\n}\nfunction assert(condition, msg) {\n  if (!condition) {\n    error(msg || \"unknow reason\");\n  }\n}\nfunction toBoolean(val) {\n  if (val === \"\")\n    return true;\n  if (val === \"false\")\n    return false;\n  return Boolean(val);\n}\nfunction remove(list, el) {\n  if (Array.isArray(list)) {\n    const i = list.indexOf(el);\n    if (i > -1) {\n      list.splice(i, 1);\n      return true;\n    }\n    return false;\n  } else {\n    if (list.has(el)) {\n      list.delete(el);\n      return true;\n    }\n    return false;\n  }\n}\nfunction callTestCallback(obj, ...args) {\n  if (false) {}\n}\nfunction unique(list) {\n  const res = [];\n  for (let i = 0, len = list.length; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (list[i] === list[j]) {\n        j = ++i;\n      }\n    }\n    res.push(list[i]);\n  }\n  return  false ? 0 : res;\n}\nfunction isPrimitive(val) {\n  return val === null || typeof val === \"string\" || typeof val === \"number\" || typeof val === \"bigint\" || typeof val === \"symbol\" || typeof val === \"boolean\" || typeof val === \"undefined\";\n}\nfunction filterUndefinedVal(ob) {\n  return Object.keys(ob).reduce((res, key) => {\n    if (res[key] === void 0) {\n      delete res[key];\n    }\n    return res;\n  }, ob);\n}\nfunction deepMerge(o, n, dp, ignores) {\n  const leftRecord = /* @__PURE__ */ new WeakMap();\n  const rightRecord = /* @__PURE__ */ new WeakMap();\n  const valueRecord = /* @__PURE__ */ new WeakMap();\n  const ignoresMap = makeMap(ignores || []);\n  const isArray = Array.isArray;\n  const isAllRefs = (a, b) => {\n    if (leftRecord.has(a) || rightRecord.has(a)) {\n      return leftRecord.has(b) || rightRecord.has(b);\n    }\n  };\n  const clone = (v) => {\n    if (isPrimitive(v) || typeof v === \"function\") {\n      return v;\n    } else if (valueRecord.has(v)) {\n      return valueRecord.get(v);\n    } else if (leftRecord.has(v)) {\n      return leftRecord.get(v);\n    } else if (rightRecord.has(v)) {\n      return rightRecord.get(v);\n    } else if (isArray(v)) {\n      if (dp)\n        v = unique(v);\n      const arr = [];\n      valueRecord.set(v, arr);\n      for (let i = 0, len = v.length; i < len; i++) {\n        arr[i] = clone(v[i]);\n      }\n      return arr;\n    } else if (typeof v === \"object\") {\n      const obj = {};\n      valueRecord.set(v, obj);\n      const keys = Reflect.ownKeys(v);\n      keys.forEach((key) => obj[key] = clone(v[key]));\n      return obj;\n    }\n  };\n  const setValue = (r, k, key) => {\n    if (r.has(k)) {\n      return r.get(k);\n    } else {\n      if (ignoresMap[key]) {\n        return k;\n      }\n      const val = clone(k);\n      if (!isPrimitive(val) && typeof val !== \"function\") {\n        r.set(k, val);\n      }\n      return val;\n    }\n  };\n  const mergeObject = (l, r) => {\n    const res = {};\n    const leftKeys = Reflect.ownKeys(l);\n    const rightKeys = Reflect.ownKeys(r);\n    leftRecord.set(l, res);\n    rightRecord.set(r, res);\n    leftKeys.forEach((key) => {\n      const lv = l[key];\n      const rv = r[key];\n      if (hasOwn(r, key)) {\n        if (isArray(lv) && isArray(rv)) {\n          const item = clone([...lv, ...rv]);\n          res[key] = dp ? unique(item) : item;\n        } else if (isPlainObject(lv) && isPlainObject(rv)) {\n          res[key] = isAllRefs(lv, rv) ? leftRecord.get(lv) : mergeObject(lv, rv);\n        } else {\n          res[key] = setValue(rightRecord, rv, key);\n        }\n      } else {\n        res[key] = setValue(leftRecord, lv, key);\n      }\n    });\n    rightKeys.forEach((key) => {\n      if (hasOwn(res, key))\n        return;\n      res[key] = setValue(rightRecord, r[key], key);\n    });\n    return res;\n  };\n  return mergeObject(o, n);\n}\nfunction isAbsolute(url) {\n  if (!/^[a-zA-Z]:\\\\/.test(url)) {\n    if (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(url)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction transformUrl(resolvePath, curPath) {\n  const baseUrl = new URL(resolvePath, location.href);\n  const realPath = new URL(curPath, baseUrl.href);\n  return realPath.href;\n}\nfunction toWsProtocol(url) {\n  const data = new URL(url);\n  if (data.protocol.startsWith(\"http\")) {\n    data.protocol = data.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    return data.toString();\n  }\n  return url;\n}\nfunction findTarget(el, selectors) {\n  for (const s of selectors) {\n    const target = el.querySelector(s);\n    if (target)\n      return target;\n  }\n  return el;\n}\nfunction setDocCurrentScript(target, code, define, url, async, originScript) {\n  if (!target)\n    return noop;\n  const el = document.createElement(\"script\");\n  if (!url && code) {\n    el.textContent = code;\n  }\n  originScript && originScript.getAttributeNames().forEach((attribute) => {\n    el.setAttribute(attribute, originScript.getAttribute(attribute) || \"\");\n  });\n  if (async) {\n    el.setAttribute(\"async\", \"true\");\n  }\n  const set = (val) => {\n    try {\n      if (define) {\n        Object.defineProperty(target, \"currentScript\", {\n          value: val,\n          writable: true,\n          configurable: true\n        });\n      } else {\n        target.currentScript = val;\n      }\n    } catch (e) {\n      if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n        warn(e);\n      }\n    }\n  };\n  set(el);\n  return () => safeWrapper(() => delete target.currentScript, true);\n}\nfunction _extends(d, b) {\n  Object.setPrototypeOf(d, b);\n  function fNOP() {\n    this.constructor = d;\n  }\n  if (b === null) {\n    d.prototype = Object.create(b);\n  } else {\n    if (b.prototype)\n      fNOP.prototype = b.prototype;\n    d.prototype = new fNOP();\n  }\n}\nfunction mapObject(obj, fn) {\n  const destObject = {};\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      destObject[key] = fn(key, obj[key]);\n    }\n  }\n  return destObject;\n}\nfunction toBase64(input, mimeType) {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(new Blob([input], { type: mimeType }));\n    reader.onload = () => resolve(reader.result);\n  });\n}\nvar hookObjectProperty = (obj, key, hookFunc) => {\n  return (...params) => {\n    if (!obj) {\n      return noop;\n    }\n    const origin = obj[key];\n    const hookedUnsafe = hookFunc(origin, ...params);\n    let hooked = hookedUnsafe;\n    if (typeof hooked === \"function\") {\n      hooked = function(...args) {\n        try {\n          return hookedUnsafe.apply(this, args);\n        } catch (e) {\n          return typeof origin === \"function\" && origin.apply(this, args);\n        }\n      };\n    }\n    obj[key] = hooked;\n    return (strict) => {\n      if (!strict || hooked === obj[key]) {\n        obj[key] = origin;\n      }\n    };\n  };\n};\nfunction getParameterByName(name, url = window.location.href) {\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  const regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"), results = regex.exec(url);\n  if (!results)\n    return null;\n  if (!results[2])\n    return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nfunction getGarfishDebugInstanceName() {\n  const DEBUG_GARFISH_TAG = \"__GARFISH_INSTANCE_DEBUG__\";\n  return localStorage.getItem(DEBUG_GARFISH_TAG) || getParameterByName(DEBUG_GARFISH_TAG);\n}\nfunction safari13Deal() {\n  let fromSetFlag = false;\n  return {\n    triggerSet() {\n      fromSetFlag = true;\n    },\n    handleDescriptor(descriptor) {\n      if (fromSetFlag === true) {\n        fromSetFlag = false;\n        if ((descriptor == null ? void 0 : descriptor.writable) === false)\n          descriptor.writable = true;\n        if ((descriptor == null ? void 0 : descriptor.enumerable) === false)\n          descriptor.enumerable = true;\n        if ((descriptor == null ? void 0 : descriptor.configurable) === false)\n          descriptor.configurable = true;\n      }\n    }\n  };\n}\nvar SOURCEMAP_REG = /[@#] sourceMappingURL=/g;\nfunction haveSourcemap(code) {\n  return SOURCEMAP_REG.test(code);\n}\nasync function createSourcemap(code, filename) {\n  const content = await toBase64(JSON.stringify({\n    version: 3,\n    sources: [filename],\n    sourcesContent: [code],\n    mappings: \";\" + code.split(\"\\n\").map(() => \"AACA\").join(\";\")\n  }));\n  return `//@ sourceMappingURL=${content}`;\n}\n\n// src/queue.ts\nvar Queue = class {\n  constructor() {\n    this.fx = [];\n    this.init = true;\n    this.lock = false;\n    this.finishDefers = /* @__PURE__ */ new Set();\n  }\n  next() {\n    if (!this.lock) {\n      this.lock = true;\n      if (this.fx.length === 0) {\n        this.init = true;\n        this.finishDefers.forEach((d) => d.resolve());\n        this.finishDefers.clear();\n      } else {\n        const fn = this.fx.shift();\n        if (fn) {\n          fn(() => {\n            this.lock = false;\n            this.next();\n          });\n        }\n      }\n    }\n  }\n  add(fn) {\n    this.fx.push(fn);\n    if (this.init) {\n      this.lock = false;\n      this.init = false;\n      this.next();\n    }\n  }\n  awaitCompletion() {\n    if (this.init)\n      return Promise.resolve();\n    const defer = {};\n    this.finishDefers.add(defer);\n    return new Promise((resolve, reject) => {\n      defer.resolve = resolve;\n      defer.reject = reject;\n    });\n  }\n};\n\n// src/sentry.ts\nvar chrome = /^\\s*at (?:(.*?) ?\\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nvar geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nvar chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nvar UNKNOWN_FUNCTION = \"?\";\nfunction extractMessage(ex) {\n  const message = ex && ex.message;\n  if (!message) {\n    return \"No error message\";\n  }\n  if (message.error && typeof message.error.message === \"string\") {\n    return message.error.message;\n  }\n  return message;\n}\nfunction computeStackTraceFromStackProp(ex) {\n  if (!ex || !ex.stack) {\n    return null;\n  }\n  const stack = [];\n  const lines = ex.stack.split(\"\\n\");\n  let isEval;\n  let submatch;\n  let parts;\n  let element;\n  for (let i = 0; i < lines.length; ++i) {\n    if (parts = chrome.exec(lines[i])) {\n      const isNative = parts[2] && parts[2].indexOf(\"native\") === 0;\n      isEval = parts[2] && parts[2].indexOf(\"eval\") === 0;\n      if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n        parts[2] = submatch[1];\n      }\n      let url = parts[2] && parts[2].indexOf(\"address at \") === 0 ? parts[2].substr(\"address at \".length) : parts[2];\n      let func = parts[1] || UNKNOWN_FUNCTION;\n      const isSafariExtension = func.indexOf(\"safari-extension\") !== -1;\n      const isSafariWebExtension = func.indexOf(\"safari-web-extension\") !== -1;\n      if (isSafariExtension || isSafariWebExtension) {\n        func = func.indexOf(\"@\") !== -1 ? func.split(\"@\")[0] : UNKNOWN_FUNCTION;\n        url = isSafariExtension ? `safari-extension:${url}` : `safari-web-extension:${url}`;\n      }\n      element = {\n        url,\n        func,\n        args: isNative ? [parts[2]] : [],\n        line: parts[3] ? +parts[3] : null,\n        column: parts[4] ? +parts[4] : null\n      };\n    } else if (parts = winjs.exec(lines[i])) {\n      element = {\n        url: parts[2],\n        func: parts[1] || UNKNOWN_FUNCTION,\n        args: [],\n        line: +parts[3],\n        column: parts[4] ? +parts[4] : null\n      };\n    } else if (parts = gecko.exec(lines[i])) {\n      isEval = parts[3] && parts[3].indexOf(\" > eval\") > -1;\n      if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n        parts[1] = parts[1] || \"eval\";\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = \"\";\n      } else if (i === 0 && !parts[5] && ex.columnNumber !== void 0) {\n        stack[0].column = ex.columnNumber + 1;\n      }\n      element = {\n        url: parts[3],\n        func: parts[1] || UNKNOWN_FUNCTION,\n        args: parts[2] ? parts[2].split(\",\") : [],\n        line: parts[4] ? +parts[4] : null,\n        column: parts[5] ? +parts[5] : null\n      };\n    } else {\n      continue;\n    }\n    if (!element.func && element.line) {\n      element.func = UNKNOWN_FUNCTION;\n    }\n    stack.push(element);\n  }\n  if (!stack.length) {\n    return null;\n  }\n  return {\n    message: extractMessage(ex),\n    name: ex.name,\n    stack\n  };\n}\nvar sourceListTags = [\n  \"link\",\n  \"style\",\n  \"script\",\n  \"img\",\n  \"video\",\n  \"audio\",\n  \"iframe\"\n];\nvar sourceNode = makeMap(sourceListTags);\nfunction computeErrorUrl(ex) {\n  if (ex && ex.filename)\n    return ex.filename;\n  const res = computeStackTraceFromStackProp(ex);\n  if (res) {\n    const urls = res.stack.map((item) => {\n      return item.url;\n    });\n    return urls[0] || null;\n  } else if (ex && ex.target && ex.target.tagName) {\n    const tagName = ex.target.tagName.toLowerCase();\n    if (sourceNode(tagName)) {\n      return ex.target.src || ex.target.href;\n    }\n  }\n  return null;\n}\nfunction filterAndWrapEventListener(type, listener, sourceList) {\n  const errorHandler = function(e) {\n    if (typeof listener === \"function\") {\n      if (sourceList) {\n        console.log(\"**********\", computeErrorUrl(e));\n        const res = sourceList.find((item) => {\n          return item.indexOf(computeErrorUrl(e)) !== -1;\n        });\n        if (res) {\n          listener(e);\n        }\n      } else {\n        listener(e);\n      }\n    }\n  };\n  const unhandledrejection = function(event) {\n    event.promise.catch((e) => {\n      if (e instanceof Error) {\n        errorHandler(e);\n      } else {\n        if (typeof listener === \"function\")\n          listener(event);\n      }\n    });\n  };\n  const filterError = function(event) {\n    if (typeof listener === \"function\") {\n      if (type === \"unhandledrejection\") {\n        unhandledrejection(event);\n      } else if (type === \"error\") {\n        errorHandler(event);\n      } else {\n        listener(event);\n      }\n    }\n  };\n  return filterError;\n}\n\n// src/domApis.ts\nvar xChar = 120;\nvar colonChar = 58;\nvar ns = \"http://www.w3.org/2000/svg\";\nvar xlinkNS = \"http://www.w3.org/1999/xlink\";\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\nvar SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nvar isSVG = makeMap(SVG_TAGS.split(\",\"));\nfunction attributesString(attributes) {\n  if (!attributes || attributes.length === 0)\n    return \"\";\n  return attributes.reduce((total, { key, value }) => {\n    return total + (value ? `${key}=\"${value}\" ` : key);\n  }, \"\");\n}\nvar DOMApis = class {\n  constructor(cusDocument) {\n    this.document = cusDocument || document;\n  }\n  isText(node) {\n    return node && node.type === \"text\";\n  }\n  isNode(node) {\n    return node && node.type === \"element\";\n  }\n  isCommentNode(node) {\n    return node && node.type === \"comment\";\n  }\n  isCssLinkNode(node) {\n    if (this.isNode(node) && node.tagName === \"link\") {\n      return !!node.attributes.find(({ key, value }) => key === \"rel\" && value === \"stylesheet\");\n    }\n    return false;\n  }\n  isIconLinkNode(node) {\n    if (this.isNode(node) && node.tagName === \"link\") {\n      return !!node.attributes.find(({ key, value }) => key === \"rel\" && value === \"icon\");\n    }\n    return false;\n  }\n  isPrefetchJsLinkNode(node) {\n    if (!this.isNode(node) || node.tagName !== \"link\")\n      return false;\n    let hasRelAttr, hasAsAttr;\n    for (const { key, value } of node.attributes) {\n      if (key === \"rel\") {\n        hasRelAttr = true;\n        if (value !== \"preload\" && value !== \"prefetch\") {\n          return false;\n        }\n      } else if (key === \"as\") {\n        hasAsAttr = true;\n        if (value !== \"script\")\n          return false;\n      }\n    }\n    return Boolean(hasRelAttr && hasAsAttr);\n  }\n  isRemoteModule(node) {\n    if (!this.isNode(node) || node.tagName !== \"meta\")\n      return false;\n    let hasNameAttr, hasSrcAttr;\n    for (const { key, value } of node.attributes) {\n      if (key === \"name\") {\n        hasNameAttr = true;\n        if (value !== \"garfish-remote-module\") {\n          return false;\n        }\n      } else if (key === \"src\") {\n        hasSrcAttr = true;\n        if (typeof value === \"undefined\" || value === \"\") {\n          return false;\n        }\n      }\n    }\n    return Boolean(hasNameAttr && hasSrcAttr);\n  }\n  removeElement(el) {\n    const parentNode = el && el.parentNode;\n    if (parentNode) {\n      parentNode.removeChild(el);\n    }\n  }\n  createElement(node) {\n    const { tagName, attributes } = node;\n    const el = isSVG(tagName) ? this.document.createElementNS(ns, tagName) : this.document.createElement(tagName);\n    this.applyAttributes(el, attributes);\n    return el;\n  }\n  createTextNode(node) {\n    return this.document.createTextNode(node.content);\n  }\n  createStyleNode(content) {\n    const el = this.document.createElement(\"style\");\n    content && (el.textContent = content);\n    this.applyAttributes(el, [{ key: \"type\", value: \"text/css\" }]);\n    return el;\n  }\n  createLinkCommentNode(node) {\n    if (this.isNode(node)) {\n      const ps = attributesString(node.attributes);\n      return `<link ${ps.slice(0, -1)}></link>`;\n    } else {\n      node = node ? `src=\"${node}\" ` : \"\";\n      return this.document.createComment(`<link ${node}execute by garfish(dynamic)></link>`);\n    }\n  }\n  createScriptCommentNode(node) {\n    if (this.isNode(node)) {\n      const { attributes, children } = node;\n      const ps = attributesString(attributes);\n      const code = (children == null ? void 0 : children[0]) ? children[0].content : \"\";\n      return this.document.createComment(`<script ${ps} execute by garfish>${code}<\\/script>`);\n    } else {\n      const { src, code } = node;\n      const url = src ? `src=\"${src}\" ` : \"\";\n      return this.document.createComment(`<script ${url}execute by garfish(dynamic)>${code}<\\/script>`);\n    }\n  }\n  applyAttributes(el, attributes) {\n    if (!attributes || attributes.length === 0)\n      return;\n    for (const { key, value } of attributes) {\n      if (key) {\n        if (value === null) {\n          el.setAttribute(key, \"\");\n        } else if (typeof value === \"string\") {\n          if (key.charCodeAt(0) !== xChar) {\n            el.setAttribute(key, value);\n          } else if (key.charCodeAt(3) === colonChar) {\n            el.setAttributeNS(xmlNS, key, value);\n          } else if (key.charCodeAt(5) === colonChar) {\n            el.setAttributeNS(xlinkNS, key, value);\n          } else {\n            el.setAttribute(key, value);\n          }\n        }\n      }\n    }\n  }\n};\n\n// src/garfish.ts\nvar __LOADER_FLAG__ = Symbol.for(\"__LOADER_FLAG__\");\nvar __GARFISH_FLAG__ = Symbol.for(\"__GARFISH_FLAG__\");\nvar __MockHtml__ = \"__garfishmockhtml__\";\nvar __MockBody__ = \"__garfishmockbody__\";\nvar __MockHead__ = \"__garfishmockhead__\";\nvar __REMOVE_NODE__ = \"__garfishremovenode__\";\n\n// src/mimeType.ts\nfunction parseContentType(input) {\n  input = input == null ? void 0 : input.trim();\n  if (!input)\n    return null;\n  let idx = 0;\n  let type = \"\";\n  let subType = \"\";\n  while (idx < input.length && input[idx] !== \"/\") {\n    type += input[idx];\n    idx++;\n  }\n  if (type.length === 0 || idx >= input.length) {\n    return null;\n  }\n  idx++;\n  while (idx < input.length && input[idx] !== \";\") {\n    subType += input[idx];\n    idx++;\n  }\n  subType = subType.replace(/[ \\t\\n\\r]+$/, \"\");\n  if (subType.length === 0)\n    return null;\n  return {\n    type: type.toLocaleLowerCase(),\n    subtype: subType.toLocaleLowerCase()\n  };\n}\nfunction isCss(mt) {\n  return mt ? mt.type === \"text\" && mt.subtype === \"css\" : false;\n}\nfunction isHtml(mt) {\n  return mt ? mt.type === \"text\" && mt.subtype === \"html\" : false;\n}\nfunction isJs(mt) {\n  const { type, subtype } = mt || {};\n  switch (type) {\n    case \"text\": {\n      switch (subtype) {\n        case \"ecmascript\":\n        case \"javascript\":\n        case \"javascript1.0\":\n        case \"javascript1.1\":\n        case \"javascript1.2\":\n        case \"javascript1.3\":\n        case \"javascript1.4\":\n        case \"javascript1.5\":\n        case \"jscript\":\n        case \"livescript\":\n        case \"x-ecmascript\":\n        case \"x-javascript\": {\n          return true;\n        }\n        default: {\n          return false;\n        }\n      }\n    }\n    case \"application\": {\n      switch (subtype) {\n        case \"ecmascript\":\n        case \"javascript\":\n        case \"x-ecmascript\":\n        case \"x-javascript\": {\n          return true;\n        }\n        default: {\n          return false;\n        }\n      }\n    }\n    default: {\n      return false;\n    }\n  }\n}\nfunction isJsonp(mt, src) {\n  const callbackRegExp = /callback/;\n  try {\n    const search = new URL(src).search;\n    const { type, subtype } = mt || {};\n    if (type === \"application\" && subtype === \"json\" && callbackRegExp.test(search)) {\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n  return false;\n}\nfunction isJsType({ src = \"\", type }) {\n  if (/\\.js$/.test(src))\n    return true;\n  if (type) {\n    if (type === \"module\")\n      return true;\n    const mimeTypeInfo = parseContentType(type);\n    if (isJsonp(mimeTypeInfo, src))\n      return true;\n    if (isJs(mimeTypeInfo))\n      return true;\n  }\n  return false;\n}\nfunction isCssType({ src = \"\", type }) {\n  if (/\\.css$/.test(src))\n    return true;\n  if (type) {\n    const mimeTypeInfo = parseContentType(type);\n    if (isCss(mimeTypeInfo))\n      return true;\n  }\n  return false;\n}\nfunction isHtmlType({\n  src = \"\",\n  type\n}) {\n  if (/\\.html$/.test(src))\n    return true;\n  if (type) {\n    const mimeTypeInfo = parseContentType(type);\n    if (isHtml(mimeTypeInfo))\n      return true;\n  }\n  return false;\n}\nfunction isGarfishConfigType({\n  type = \"\"\n}) {\n  return /garfish-config/i.test(type);\n}\n\n// src/dispatchEvents.ts\nvar reactEvents = [\n  \"onAbort\",\n  \"onAnimationCancel\",\n  \"onAnimationEnd\",\n  \"onAnimationIteration\",\n  \"onAuxClick\",\n  \"onBlur\",\n  \"onChange\",\n  \"onClick\",\n  \"onClose\",\n  \"onContextMenu\",\n  \"onDoubleClick\",\n  \"onError\",\n  \"onFocus\",\n  \"onGotPointerCapture\",\n  \"onInput\",\n  \"onKeyDown\",\n  \"onKeyPress\",\n  \"onKeyUp\",\n  \"onLoad\",\n  \"onLoadEnd\",\n  \"onLoadStart\",\n  \"onLostPointerCapture\",\n  \"onMouseDown\",\n  \"onMouseMove\",\n  \"onMouseOut\",\n  \"onMouseOver\",\n  \"onMouseUp\",\n  \"onPointerCancel\",\n  \"onPointerDown\",\n  \"onPointerEnter\",\n  \"onPointerLeave\",\n  \"onPointerMove\",\n  \"onPointerOut\",\n  \"onPointerOver\",\n  \"onPointerUp\",\n  \"onReset\",\n  \"onResize\",\n  \"onScroll\",\n  \"onSelect\",\n  \"onSelectionChange\",\n  \"onSelectStart\",\n  \"onSubmit\",\n  \"onTouchCancel\",\n  \"onTouchMove\",\n  \"onTouchStart\",\n  \"onTouchEnd\",\n  \"onTransitionCancel\",\n  \"onTransitionEnd\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onDragEnter\",\n  \"onDragExit\",\n  \"onDragLeave\",\n  \"onDragOver\",\n  \"onDragStart\",\n  \"onDrop\",\n  \"onFocusOut\"\n];\nvar divergentNativeEvents = {\n  onDoubleClick: \"dblclick\"\n};\nvar mimickedReactEvents = {\n  onInput: \"onChange\",\n  onFocusOut: \"onBlur\",\n  onSelectionChange: \"onSelect\"\n};\nfunction dispatchEvents(shadowRoot) {\n  const removeEventListeners = [];\n  reactEvents.forEach(function(reactEventName) {\n    const nativeEventName = getNativeEventName(reactEventName);\n    function retargetEvent(event) {\n      const path = event.path || event.composedPath && event.composedPath() || composedPath(event.target);\n      for (let i = 0; i < path.length; i++) {\n        const el = path[i];\n        let props = null;\n        const reactComponent = findReactComponent(el);\n        const eventHandlers = findReactEventHandlers(el);\n        if (!eventHandlers) {\n          props = findReactProps(reactComponent);\n        } else {\n          props = eventHandlers;\n        }\n        if (reactComponent && props) {\n          dispatchEvent(event, reactEventName, props);\n        }\n        if (reactComponent && props && mimickedReactEvents[reactEventName]) {\n          dispatchEvent(event, mimickedReactEvents[reactEventName], props);\n        }\n        if (event.cancelBubble) {\n          break;\n        }\n        if (el === shadowRoot) {\n          break;\n        }\n      }\n    }\n    shadowRoot.addEventListener(nativeEventName, retargetEvent, false);\n    removeEventListeners.push(function() {\n      shadowRoot.removeEventListener(nativeEventName, retargetEvent, false);\n    });\n  });\n  return function() {\n    removeEventListeners.forEach(function(removeEventListener) {\n      removeEventListener();\n    });\n  };\n}\nfunction findReactEventHandlers(item) {\n  return findReactProperty(item, \"__reactEventHandlers\");\n}\nfunction findReactComponent(item) {\n  return findReactProperty(item, \"_reactInternal\");\n}\nfunction findReactProperty(item, propertyPrefix) {\n  for (const key in item) {\n    if (hasOwn(item, key) && key.indexOf(propertyPrefix) !== -1) {\n      return item[key];\n    }\n  }\n}\nfunction findReactProps(component) {\n  if (!component)\n    return void 0;\n  if (component.memoizedProps)\n    return component.memoizedProps;\n  if (component._currentElement && component._currentElement.props)\n    return component._currentElement.props;\n}\nfunction dispatchEvent(event, eventType, componentProps) {\n  event.persist = function() {\n    event.isPersistent = () => true;\n  };\n  if (componentProps[eventType]) {\n    componentProps[eventType](event);\n  }\n}\nfunction getNativeEventName(reactEventName) {\n  if (divergentNativeEvents[reactEventName]) {\n    return divergentNativeEvents[reactEventName];\n  }\n  return reactEventName.replace(/^on/, \"\").toLowerCase();\n}\nfunction composedPath(el) {\n  const path = [];\n  while (el) {\n    path.push(el);\n    if (el.tagName === \"HTML\") {\n      path.push(document);\n      path.push(window);\n      return path;\n    }\n    el = el.parentElement;\n  }\n}\n\n// src/container.ts\nvar appContainerId = \"garfish_app_for\";\nfunction createAppContainer(appInfo) {\n  let htmlNode = document.createElement(\"div\");\n  const appContainer = document.createElement(\"div\");\n  if (appInfo.sandbox && appInfo.sandbox.strictIsolation) {\n    htmlNode = document.createElement(\"html\");\n    const root = appContainer.attachShadow({ mode: \"open\" });\n    root.appendChild(htmlNode);\n    dispatchEvents(root);\n  } else {\n    htmlNode.setAttribute(__MockHtml__, \"\");\n    appContainer.appendChild(htmlNode);\n  }\n  appContainer.id = `${appContainerId}_${appInfo.name}_${createKey()}`;\n  return {\n    htmlNode,\n    appContainer\n  };\n}\nfunction waitElementReady(selector, callback) {\n  const elem = document.querySelector(selector);\n  if (elem !== null) {\n    callback(elem);\n    return;\n  }\n  setTimeout(function() {\n    waitElementReady(selector, callback);\n  }, 50);\n}\nfunction delay(duration) {\n  return new Promise(function(resolve) {\n    setTimeout(resolve, duration);\n  });\n}\nfunction waitElement(selector, timeout = 3e3) {\n  const waitPromise = new Promise(function(resolve) {\n    waitElementReady(selector, function(elem) {\n      return resolve(elem);\n    });\n  });\n  return Promise.race([delay(timeout), waitPromise]);\n}\nasync function getRenderNode(domGetter) {\n  assert(domGetter, `Invalid domGetter:\n ${domGetter}.`);\n  let appWrapperNode;\n  if (typeof domGetter === \"string\") {\n    appWrapperNode = await waitElement(domGetter);\n  } else if (typeof domGetter === \"function\") {\n    appWrapperNode = await Promise.resolve(domGetter());\n  }\n  assert(appWrapperNode instanceof Element, `Invalid domGetter: ${domGetter}`);\n  return appWrapperNode;\n}\n\n// src/templateParse.ts\nfunction Attributes({ name, value }) {\n  this.key = name;\n  this.value = value;\n}\nvar generateAttributes = (el) => {\n  const list = [];\n  const attrs = el.attributes;\n  const len = attrs.length;\n  if (len > 0) {\n    if (len === 1) {\n      list[0] = new Attributes(attrs[0]);\n    } else if (len === 2) {\n      list[0] = new Attributes(attrs[0]);\n      list[1] = new Attributes(attrs[1]);\n    } else {\n      for (let i = 0; i < len; i++) {\n        list[i] = new Attributes(attrs[i]);\n      }\n    }\n  }\n  return list;\n};\nvar createElement = (el, filter) => {\n  switch (el.nodeType) {\n    case 3 /* TEXT */:\n      return {\n        type: \"text\",\n        content: el.textContent\n      };\n    case 8 /* COMMENT */:\n      return {\n        type: \"comment\",\n        content: el.textContent\n      };\n    case 1 /* ELEMENT */:\n      return filter({\n        type: \"element\",\n        tagName: el.tagName.toLowerCase(),\n        attributes: generateAttributes(el),\n        children: Array.from(el.childNodes).map((node) => {\n          return createElement(node, filter);\n        })\n      });\n    default:\n      error(`Invalid node type \"${el.nodeType}\"`);\n  }\n};\nfunction templateParse(code, tags) {\n  let astTree = [];\n  const htmlNode = document.createElement(\"html\");\n  const collectionEls = {};\n  const filter = (el) => {\n    if (tags.includes(el.tagName)) {\n      collectionEls[el.tagName].push(el);\n    }\n    return el;\n  };\n  htmlNode.innerHTML = code;\n  for (const tag of tags) {\n    collectionEls[tag] = [];\n  }\n  astTree = Array.from(htmlNode.childNodes).map((node) => {\n    return createElement(node, filter);\n  });\n  return [astTree, collectionEls];\n}\n\n// src/logger.ts\n\nvar log = debug__WEBPACK_IMPORTED_MODULE_0___default()(\"garfish\");\nvar coreLog = log.extend(\"core\");\nvar routerLog = log.extend(\"router\");\n\n// src/lock.ts\nvar Lock = class {\n  constructor() {\n    this.id = 0;\n    this.lockQueue = [];\n  }\n  genId() {\n    return ++this.id;\n  }\n  getId() {\n    return this.id;\n  }\n  async wait(id) {\n    const { lockQueue } = this;\n    const firstLock = lockQueue[0];\n    const lastLock = firstLock ? lockQueue[lockQueue.length - 1] : void 0;\n    if ((firstLock == null ? void 0 : firstLock.id) === id)\n      return;\n    let lockItem = lockQueue.find((item) => item.id === id);\n    if (!lockItem) {\n      let promiseResolve = () => {\n      };\n      const waiting = new Promise((resolve) => {\n        promiseResolve = resolve;\n      });\n      lockItem = { id, waiting, resolve: promiseResolve };\n      lockQueue.push(lockItem);\n    }\n    if (lastLock) {\n      await lastLock.waiting;\n    }\n  }\n  release() {\n    const { lockQueue } = this;\n    const firstLock = lockQueue[0];\n    if (!firstLock)\n      return;\n    lockQueue.shift();\n    firstLock.resolve();\n  }\n  clear() {\n    this.lockQueue = [];\n  }\n};\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/browser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/browser.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/common.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/common.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+debug@4.3.4/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (true) {\n     // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var _global; }\n}();\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+garfish@1.13.3/node_modules/garfish/dist/esm/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+garfish@1.13.3/node_modules/garfish/dist/esm/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Garfish\": () => (/* reexport safe */ _garfish_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"default\": () => (/* binding */ GarfishInstance),\n/* harmony export */   \"defineCustomElements\": () => (/* binding */ defineCustomElements)\n/* harmony export */ });\n/* harmony import */ var _garfish_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @garfish/core */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+core@1.13.3/node_modules/@garfish/core/dist/esm/index.js\");\n/* harmony import */ var _garfish_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @garfish/router */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+router@1.13.3/node_modules/@garfish/router/dist/esm/index.js\");\n/* harmony import */ var _garfish_browser_vm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @garfish/browser-vm */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-vm@1.13.3/node_modules/@garfish/browser-vm/dist/esm/index.js\");\n/* harmony import */ var _garfish_browser_snapshot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @garfish/browser-snapshot */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+browser-snapshot@1.13.3/node_modules/@garfish/browser-snapshot/dist/esm/index.js\");\n/* harmony import */ var _garfish_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @garfish/utils */ \"./node_modules/.pnpm/registry.npmmirror.com+@garfish+utils@1.13.3/node_modules/@garfish/utils/dist/esm/index.js\");\n// src/index.ts\n\n\n// src/instance.ts\n\n\n\n\n\nfunction createContext() {\n  let fresh = false;\n  if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.inBrowser)() && window[\"__GARFISH__\"] && window[\"Garfish\"]) {\n    return window[\"Garfish\"];\n  }\n  const GarfishInstance2 = new _garfish_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    plugins: [(0,_garfish_router__WEBPACK_IMPORTED_MODULE_1__.GarfishRouter)(), (0,_garfish_browser_vm__WEBPACK_IMPORTED_MODULE_2__.GarfishBrowserVm)(), (0,_garfish_browser_snapshot__WEBPACK_IMPORTED_MODULE_3__.GarfishBrowserSnapshot)()]\n  });\n  const set = (namespace, val = GarfishInstance2) => {\n    if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.hasOwn)(window, namespace)) {\n      if (!(window[namespace] && window[namespace].flag === _garfish_utils__WEBPACK_IMPORTED_MODULE_4__.__GARFISH_FLAG__)) {\n        const next = () => {\n          fresh = true;\n          if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n            (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.warn)(`\"Window.${namespace}\" will be overwritten by \"garfish\".`);\n          }\n        };\n        const desc = Object.getOwnPropertyDescriptor(window, namespace);\n        if (desc) {\n          if (desc.configurable) {\n            (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.def)(window, namespace, val);\n            next();\n          } else if (desc.writable) {\n            window[namespace] = val;\n            next();\n          }\n        }\n      }\n    } else {\n      fresh = true;\n      (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.def)(window, namespace, val);\n    }\n  };\n  if ((0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.inBrowser)()) {\n    set(\"Garfish\");\n    (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.def)(window, \"__GARFISH__\", true);\n  }\n  if (fresh) {\n    if (typeof process !== \"undefined\" && process.env && \"development\" ? \"development\" !== \"production\" : false) {\n      if (window[\"Garfish\"].version !== \"1.13.3\") {\n        (0,_garfish_utils__WEBPACK_IMPORTED_MODULE_4__.warn)('The \"garfish version\" used by the main and sub-applications is inconsistent.');\n      }\n    }\n  }\n  return GarfishInstance2;\n}\nvar GarfishInstance = createContext();\n\n// src/customElement.ts\nfunction generateCustomerElement(htmlTag, options) {\n  class MicroApp extends HTMLElement {\n    constructor() {\n      super();\n      this.appInfo = {\n        name: \"\",\n        entry: \"\",\n        basename: \"\"\n      };\n      this.options = {\n        delay: 200\n      };\n      this.state = this._observerAppState({\n        isLoading: false,\n        error: null,\n        promise: null,\n        loaded: null,\n        pastDelay: false\n      });\n      this.options = options;\n    }\n    _observerAppState(state) {\n      return new Proxy(state, {\n        set: (target, p, value, receiver) => {\n          const getPlaceHolderAndAppend = () => {\n            if (this.placeholder && this.contains(this.placeholder)) {\n              this.removeChild(this.placeholder);\n            }\n            const placeholder = this.options.loading && this.options.loading({\n              isLoading: this.state.isLoading,\n              error: this.state.error,\n              pastDelay: this.state.pastDelay\n            });\n            placeholder && this.appendChild(placeholder);\n            return placeholder;\n          };\n          const res = Reflect.set(target, p, value, receiver);\n          if (p === \"error\" && value) {\n            const placeholder = getPlaceHolderAndAppend();\n            if (placeholder)\n              this.placeholder = placeholder;\n          } else if (p === \"pastDelay\" && value === true) {\n            const placeholder = getPlaceHolderAndAppend();\n            if (placeholder)\n              this.placeholder = placeholder;\n          } else if (p === \"isLoading\" && value === true) {\n            const placeholder = getPlaceHolderAndAppend();\n            if (placeholder)\n              this.placeholder = placeholder;\n          } else if (p === \"isLoading\" && value === false) {\n            if (!this.state.error && this.contains(this.placeholder)) {\n              this.removeChild(this.placeholder);\n            }\n          }\n          return res;\n        }\n      });\n    }\n    _loadApp() {\n      if (this.state.isLoading)\n        return;\n      this.state.isLoading = true;\n      if (typeof this.options.delay === \"number\") {\n        if (this.options.delay === 0) {\n          this.state.pastDelay = true;\n        } else {\n          this._delay = setTimeout(() => {\n            this.state.pastDelay = true;\n          }, this.options.delay);\n        }\n      }\n      this.state.promise = GarfishInstance.loadApp(this.appInfo.name, {\n        entry: this.appInfo.entry,\n        domGetter: () => this,\n        basename: this.appInfo.basename,\n        sandbox: {\n          snapshot: false,\n          strictIsolation: this.hasAttribute(\"shadow\") || false\n        }\n      });\n    }\n    _clearTimeouts() {\n      clearTimeout(this._delay);\n    }\n    async connectedCallback() {\n      this.appInfo = {\n        name: this.getAttribute(\"name\") || \"\",\n        entry: this.getAttribute(\"entry\") || \"\",\n        basename: this.getAttribute(\"basename\") || \"/\"\n      };\n      try {\n        this._loadApp();\n        this.state.loaded = await this.state.promise;\n        if (this.state.loaded.mounted) {\n          this.state.loaded.show();\n        } else {\n          await this.state.loaded.mount();\n        }\n      } catch (error) {\n        this.state.error = error;\n      } finally {\n        this.state.isLoading = false;\n      }\n    }\n    disconnectedCallback() {\n      this._clearTimeouts();\n      if (this.state.loaded) {\n        this.state.loaded.hide();\n      }\n    }\n    async adoptedCallback() {\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n      console.log(\"Custom square element attributes changed.\", name, oldValue, newValue);\n    }\n  }\n  if (!customElements.get(htmlTag)) {\n    GarfishInstance.run(options.config || {});\n    customElements.define(htmlTag, MicroApp);\n  }\n}\nfunction createLoadableWebComponent(htmlTag, options) {\n  if (typeof htmlTag !== \"string\") {\n    throw new Error(\"garfish requires a `htmlTag` name\");\n  }\n  if (!options.loading) {\n    throw new Error(\"garfish requires a `loading` component\");\n  }\n  const opts = Object.assign({\n    loading: false,\n    delay: 200,\n    timeout: null\n  }, options);\n  return generateCustomerElement(htmlTag, opts);\n}\nfunction defineCustomElements(htmlTag, options) {\n  return createLoadableWebComponent(htmlTag, options);\n}\n\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+garfish@1.13.3/node_modules/garfish/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js?");

/***/ }),

/***/ "./src/main-app/index.js":
/*!*******************************!*\
  !*** ./src/main-app/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var garfish__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! garfish */ \"./node_modules/.pnpm/registry.npmmirror.com+garfish@1.13.3/node_modules/garfish/dist/esm/index.js\");\n\n\nGarfish.run({\n  basename: '/',\n  domGetter: '#subapp',\n  apps: [\n    {\n      name: 'vue',\n      activeWhen: '/vue',\n      entry: 'http://localhost:8080/index.js', // js\n    },\n  ],\n});\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./src/main-app/index.js?");

/***/ }),

/***/ "./node_modules/.pnpm/registry.npmmirror.com+@alioth-org+es-module-lexer@1.1.0/node_modules/@alioth-org/es-module-lexer/dist/lexer.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/registry.npmmirror.com+@alioth-org+es-module-lexer@1.1.0/node_modules/@alioth-org/es-module-lexer/dist/lexer.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n/* es-module-lexer 1.1.0 */\nconst A=1===new Uint8Array(new Uint16Array([1]).buffer)[0];function parse(E,g=\"@\"){if(!C)return init().then((()=>parse(E)));const I=E.length+1,K=(C.__heap_base.value||C.__heap_base)+4*I-C.memory.buffer.byteLength;K>0&&C.memory.grow(Math.ceil(K/65536));const k=C.sa(I-1);if((A?B:Q)(E,new Uint16Array(C.memory.buffer,k,I)),!C.parse())throw Object.assign(new Error(`Parse error ${g}:${E.slice(0,C.e()).split(\"\\n\").length}:${C.e()-E.lastIndexOf(\"\\n\",C.e()-1)}`),{idx:C.e()});const o=[],D=[];for(;C.ri();){const A=C.is(),Q=C.ie(),B=C.ai(),g=C.id(),I=C.ss(),K=C.se();let k;C.ip()&&(k=w(E.slice(-1===g?A-1:A,-1===g?Q+1:Q))),o.push({n:k,s:A,e:Q,ss:I,se:K,d:g,a:B})}for(;C.re();){const A=C.es(),Q=C.ee(),B=C.els(),g=C.ele(),I=E.slice(A,Q),K=I[0],k=B<0?void 0:E.slice(B,g),o=k?k[0]:\"\";D.push({s:A,e:Q,ls:B,le:g,n:'\"'===K||\"'\"===K?w(I):I,ln:'\"'===o||\"'\"===o?w(k):k})}function w(A){try{return(0,eval)(A)}catch(A){}}return[o,D,!!C.f()]}function Q(A,Q){const B=A.length;let C=0;for(;C<B;){const B=A.charCodeAt(C);Q[C++]=(255&B)<<8|B>>>8}}function B(A,Q){const B=A.length;let C=0;for(;C<B;)Q[C]=A.charCodeAt(C++)}let C,E;const init=()=>{var A;return E||(E=WebAssembly.compile((A=\"AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMtLAABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDBQYAAAcABgIFBAUBcAEBAQUDAQABBg8CfwFBsPIAC38AQbDyAAsHcBMGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwDZWxzAA0DZWxlAA4CcmkADwJyZQAQAWYAEQVwYXJzZQASC19faGVhcF9iYXNlAwEKsjssaAEBf0EAIAA2AvgJQQAoAtQJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgL8CUEAIAA2AoAKQQBBADYC2AlBAEEANgLoCUEAQQA2AuAJQQBBADYC3AlBAEEANgLwCUEAQQA2AuQJIAELnwEBA39BACgC6AkhBEEAQQAoAoAKIgU2AugJQQAgBDYC7AlBACAFQSBqNgKACiAEQRxqQdgJIAQbIAU2AgBBACgCzAkhBEEAKALICSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGGyAEIANGGzYCDCAFIAM2AhQgBUEANgIQIAUgAjYCBCAFQQA2AhwgBUEAKALICSADRjoAGAtWAQF/QQAoAvAJIgRBEGpB3AkgBBtBACgCgAoiBDYCAEEAIAQ2AvAJQQAgBEEUajYCgAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKECgsVAEEAKALgCSgCAEEAKALUCWtBAXULHgEBf0EAKALgCSgCBCIAQQAoAtQJa0EBdUF/IAAbCxUAQQAoAuAJKAIIQQAoAtQJa0EBdQseAQF/QQAoAuAJKAIMIgBBACgC1AlrQQF1QX8gABsLHgEBf0EAKALgCSgCECIAQQAoAtQJa0EBdUF/IAAbCzsBAX8CQEEAKALgCSgCFCIAQQAoAsgJRw0AQX8PCwJAIABBACgCzAlHDQBBfg8LIABBACgC1AlrQQF1CwsAQQAoAuAJLQAYCxUAQQAoAuQJKAIAQQAoAtQJa0EBdQsVAEEAKALkCSgCBEEAKALUCWtBAXULHgEBf0EAKALkCSgCCCIAQQAoAtQJa0EBdUF/IAAbCx4BAX9BACgC5AkoAgwiAEEAKALUCWtBAXVBfyAAGwslAQF/QQBBACgC4AkiAEEcakHYCSAAGygCACIANgLgCSAAQQBHCyUBAX9BAEEAKALkCSIAQRBqQdwJIAAbKAIAIgA2AuQJIABBAEcLCABBAC0AiAoL5gwBBn8jAEGA0ABrIgAkAEEAQQE6AIgKQQBBACgC0Ak2ApAKQQBBACgC1AlBfmoiATYCpApBACABQQAoAvgJQQF0aiICNgKoCkEAQQA7AYoKQQBBADsBjApBAEEAOgCUCkEAQQA2AoQKQQBBADoA9AlBACAAQYAQajYCmApBACAANgKcCkEAQQA6AKAKAkACQAJAAkADQEEAIAFBAmoiAzYCpAogASACTw0BAkAgAy8BACICQXdqQQVJDQACQAJAAkACQAJAIAJBm39qDgUBCAgIAgALIAJBIEYNBCACQS9GDQMgAkE7Rg0CDAcLQQAvAYwKDQEgAxATRQ0BIAFBBGpBgghBChArDQEQFEEALQCICg0BQQBBACgCpAoiATYCkAoMBwsgAxATRQ0AIAFBBGpBjAhBChArDQAQFQtBAEEAKAKkCjYCkAoMAQsCQCABLwEEIgNBKkYNACADQS9HDQQQFgwBC0EBEBcLQQAoAqgKIQJBACgCpAohAQwACwtBACECIAMhAUEALQD0CQ0CDAELQQAgATYCpApBAEEAOgCICgsDQEEAIAFBAmoiAzYCpAoCQAJAAkACQAJAAkACQAJAAkAgAUEAKAKoCk8NACADLwEAIgJBd2pBBUkNCAJAAkACQAJAAkACQAJAAkACQAJAIAJBYGoOChIRBhEREREFAQIACwJAAkACQAJAIAJBoH9qDgoLFBQDFAEUFBQCAAsgAkGFf2oOAwUTBgkLQQAvAYwKDRIgAxATRQ0SIAFBBGpBgghBChArDRIQFAwSCyADEBNFDREgAUEEakGMCEEKECsNERAVDBELIAMQE0UNECABKQAEQuyAhIOwjsA5Ug0QIAEvAQwiA0F3aiIBQRdLDQ5BASABdEGfgIAEcUUNDgwPC0EAQQAvAYwKIgFBAWo7AYwKQQAoApgKIAFBA3RqIgFBATYCACABQQAoApAKNgIEDA8LQQAvAYwKIgJFDQtBACACQX9qIgQ7AYwKQQAvAYoKIgJFDQ4gAkECdEEAKAKcCmpBfGooAgAiBSgCFEEAKAKYCiAEQf//A3FBA3RqKAIERw0OAkAgBSgCBA0AIAUgAzYCBAtBACACQX9qOwGKCiAFIAFBBGo2AgwMDgsCQEEAKAKQCiIBLwEAQSlHDQBBACgC6AkiA0UNACADKAIEIAFHDQBBAEEAKALsCSIDNgLoCQJAIANFDQAgA0EANgIcDAELQQBBADYC2AkLQQBBAC8BjAoiA0EBajsBjApBACgCmAogA0EDdGoiA0EGQQJBAC0AoAobNgIAIAMgATYCBEEAQQA6AKAKDA0LQQAvAYwKIgFFDQlBACABQX9qIgE7AYwKQQAoApgKIAFB//8DcUEDdGooAgBBBEYNBAwMC0EnEBgMCwtBIhAYDAoLIAJBL0cNCQJAAkAgAS8BBCIBQSpGDQAgAUEvRw0BEBYMDAtBARAXDAsLAkACQEEAKAKQCiIBLwEAIgMQGUUNAAJAAkAgA0FVag4EAAgBAwgLIAFBfmovAQBBK0YNBgwHCyABQX5qLwEAQS1GDQUMBgsCQCADQf0ARg0AIANBKUcNBUEAKAKYCkEALwGMCkEDdGooAgQQGkUNBQwGC0EAKAKYCkEALwGMCkEDdGoiAigCBBAbDQUgAigCAEEGRg0FDAQLIAFBfmovAQBBUGpB//8DcUEKSQ0DDAQLQQAoApgKQQAvAYwKIgFBA3QiA2pBACgCkAo2AgRBACABQQFqOwGMCkEAKAKYCiADakEDNgIACxAcDAcLQQAtAPQJQQAvAYoKQQAvAYwKcnJFIQIMCQsgARAdDQAgA0UNACADQS9GQQAtAJQKQQBHcQ0AIAFBfmohAUEAKALUCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApAKIAEvAQAhAyABQX5qIgQhASADEB5FDQALIARBAmohBAtBASEFIANB//8DcRAfRQ0BIARBfmohAQJAA0AgAUECaiIDIAJNDQFBACABNgKQCiABLwEAIQMgAUF+aiIEIQEgAxAfDQALIARBAmohAwsgAxAgRQ0BECFBAEEAOgCUCgwFCxAhQQAhBQtBACAFOgCUCgwDCxAiQQAhAgwFCyADQaABRw0BC0EAQQE6AKAKC0EAQQAoAqQKNgKQCgtBACgCpAohAQwACwsgAEGA0ABqJAAgAgsdAAJAQQAoAtQJIABHDQBBAQ8LIABBfmovAQAQHgvFCgEHf0EAQQAoAqQKIgBBDGoiATYCpApBACgC8AkhAkEBECYhAwJAAkACQAJAAkACQAJAQQAoAqQKIgQgAUcNACADECVFDQELAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKkCkEBECYhBEEAKAKkCiEBA0ACQAJAIARB//8DcSIDQSJGDQAgA0EnRg0AIAMQKBpBACgCpAohAwwBCyADEBhBAEEAKAKkCkECaiIDNgKkCgtBARAmGgJAIAEgAxApIgRBLEcNAEEAQQAoAqQKQQJqNgKkCkEBECYhBAtBACgCpAohAyAEQf0ARg0DIAMgAUYNCiADIQEgA0EAKAKoCk0NAAwKCwtBACAEQQJqNgKkCkEBECYaQQAoAqQKIgMgAxApGgwCC0EAQQA6AIgKAkACQAJAAkACQAJAIANBn39qDgwCCAQBCAMICAgICAUACyADQfYARg0EDAcLQQAgBEEOaiIANgKkCkHhACEDAkBBARAmIgJB4QBHDQBBACEBQQAoAqQKIgIQE0UNCyACKQACQvOA5IPgjcAxUg0LIAIvAQoQH0UNC0EAIAJBCmo2AqQKQQAQJiECC0HmACEDQQAhASACQeYARw0JQQAhAUEAKAKkCiICEBNFDQogAkECakGkCEEOECsNCiACLwEQIgVBd2oiBkEXSw0HQQEgBnRBn4CABHFFDQcMCAtBACAEQQpqNgKkCkEBECYaQQAoAqQKIQQLQQAgBEEQajYCpAoCQEEBECYiBEEqRw0AQQBBACgCpApBAmo2AqQKQQEQJiEEC0EAKAKkCiEDIAQQKBogA0EAKAKkCiIEIAMgBBACQQBBACgCpApBfmo2AqQKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQHkUNAEEAIARBCmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoGiADQQAoAqQKIgQgAyAEEAJBAEEAKAKkCkF+ajYCpAoPC0EAIARBBGoiBDYCpAoLQQAgBEEEaiIDNgKkCkEAQQA6AIgKAkADQEEAIANBAmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoQSByQfsARg0BQQAoAqQKIgQgA0YNBCADIAQgAyAEEAJBARAmQSxHDQFBACgCpAohAwwACwtBAEEAKAKkCkF+ajYCpAoPC0EAIANBAmo2AqQKC0EBECYhBEEAKAKkCiEDAkAgBEHmAEcNACADQQJqQZ4IQQYQKw0AQQAgA0EIajYCpAogAEEBECYQJyACQRBqQdwJIAIbIQMDQCADKAIAIgNFDQIgA0IANwIIIANBEGohAwwACwtBACADQX5qNgKkCgsPCwJAIAVBWGoOAwEDAQALIAVBoAFHDQILQQAgAkEQajYCpApBASEBAkBBARAmIgJBKkcNAEEAQQAoAqQKQQJqNgKkCkEBECYhAgsgAkEoRw0AIAQgAEEAQQAQAkEAIARBDGo2AqQKDwtB4wAhAwJAIAJB4wBGDQAgAiEDDAELQQAoAqQKIgIQE0UNACACKQACQuyAhIOwjsA5Ug0AAkACQCACLwEKIgVBd2oiBkEXSw0AQQEgBnRBn4CABHENAQsgBUGgAUYNACAFQfsARw0BC0EAIAJBCmo2AqQKQQEhAUEBECYiA0H7AEcNACAEIABBAEEAEAJBACAEQQxqNgKkCg8LQQAoAqQKIQIgAxAoGgJAAkAgAUUNAEEAKAKkCiIDIAJNDQAgBCAAIAIgAxACQQAoAqQKQX5qIQMMAQsgBCAAQQBBABACIARBDGohAwtBACADNgKkCg8LECILvgYBBH9BAEEAKAKkCiIAQQxqIgE2AqQKAkACQAJAAkACQAJAAkACQAJAAkBBARAmIgJBWWoOCAQCAQQBAQEDAAsgAkEiRg0DIAJB+wBGDQQLQQAoAqQKIAFHDQJBACAAQQpqNgKkCg8LQQAoApgKQQAvAYwKIgJBA3RqIgFBACgCpAo2AgRBACACQQFqOwGMCiABQQU2AgBBACgCkAovAQBBLkYNA0EAQQAoAqQKIgFBAmo2AqQKQQEQJiECIABBACgCpApBACABEAFBAEEALwGKCiIBQQFqOwGKCkEAKAKcCiABQQJ0akEAKALoCTYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKkCkF+ajYCpAoPCyACEBhBAEEAKAKkCkECaiICNgKkCgJAAkACQEEBECZBV2oOBAECAgACC0EAQQAoAqQKQQJqNgKkCkEBECYaQQAoAugJIgEgAjYCBCABQQE6ABggAUEAKAKkCiICNgIQQQAgAkF+ajYCpAoPC0EAKALoCSIBIAI2AgQgAUEBOgAYQQBBAC8BjApBf2o7AYwKIAFBACgCpApBAmo2AgxBAEEALwGKCkF/ajsBigoPC0EAQQAoAqQKQX5qNgKkCg8LQQBBACgCpApBAmo2AqQKQQEQJkHtAEcNAkEAKAKkCiICQQJqQZYIQQYQKw0CQQAoApAKLwEAQS5GDQIgACAAIAJBCGpBACgCzAkQAQ8LQQAvAYwKDQJBACgCpAohAkEAKAKoCiEDA0AgAiADTw0FAkACQCACLwEAIgFBJ0YNACABQSJHDQELIAAgARAnDwtBACACQQJqIgI2AqQKDAALC0EAKAKkCiECQQAvAYwKDQICQANAAkACQAJAIAJBACgCqApPDQBBARAmIgJBIkYNASACQSdGDQEgAkH9AEcNAkEAQQAoAqQKQQJqNgKkCgtBARAmGkEAKAKkCiICKQAAQuaAyIPwjcA2Ug0HQQAgAkEIajYCpApBARAmIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqQKQQJqIgI2AqQKDAALCyAAIAIQJwsPC0EAQQAoAqQKQX5qNgKkCg8LQQAgAkF+ajYCpAoPCxAiC0cBA39BACgCpApBAmohAEEAKAKoCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqQKC5gBAQN/QQBBACgCpAoiAUECajYCpAogAUEGaiEBQQAoAqgKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqQKDAELIAFBfmohAQtBACABNgKkCg8LIAFBAmohAQwACwuIAQEEf0EAKAKkCiEBQQAoAqgKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKkChAiDwtBACABNgKkCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZgJQQUQIw0AIABBoglBAxAjDQAgAEGoCUECECMhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBtAlBBhAjDwsgAEF+ai8BAEE9Rg8LIABBfmpBrAlBBBAjDwsgAEF+akHACUEDECMPC0EAIQELIAEL3gEBBH9BACgCpAohAEEAKAKoCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqQKQQBBAC8BjAoiAkEBajsBjApBACgCmAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCpApBAEEALwGMCkF/aiIAOwGMCkEAKAKYCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqQKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQbwIQQIQIw8LIABBfGpBwAhBAxAjDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAkDwsgAEF6akHjABAkDwsgAEF8akHGCEEEECMPCyAAQXxqQc4IQQYQIw8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2ghBBhAjDwsgAEF4akHmCEECECMPCyAAQX5qQeoIQQQQIw8LQQEhASAAQX5qIgBB6QAQJA0EIABB8ghBBRAjDwsgAEF+akHkABAkDwsgAEF+akH8CEEHECMPCyAAQX5qQYoJQQQQIw8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAkDwsgAEF8akGSCUEDECMhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAlcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHqCEEEECMPCyAAQX5qLwEAQfUARw0AIABBfGpBzghBBhAjIQELIAELcAECfwJAAkADQEEAQQAoAqQKIgBBAmoiATYCpAogAEEAKAKoCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAqGgwBC0EAIABBBGo2AqQKDAALCxAiCws1AQF/QQBBAToA9AlBACgCpAohAEEAQQAoAqgKQQJqNgKkCkEAIABBACgC1AlrQQF1NgKECgtJAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC1AkiBUkNACAAIAEgAhArDQACQCAAIAVHDQBBAQ8LIAQvAQAQHiEDCyADCz0BAn9BACECAkBBACgC1AkiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILaAECf0EBIQECQAJAIABBX2oiAkEFSw0AQQEgAnRBMXENAQsgAEH4/wNxQShGDQAgAEFGakH//wNxQQZJDQACQCAAQaV/aiICQQNLDQAgAkEBRw0BCyAAQYV/akH//wNxQQRJIQELIAELnAEBA39BACgCpAohAQJAA0ACQAJAIAEvAQAiAkEvRw0AAkAgAS8BAiIBQSpGDQAgAUEvRw0EEBYMAgsgABAXDAELAkACQCAARQ0AIAJBd2oiAUEXSw0BQQEgAXRBn4CABHFFDQEMAgsgAhAfRQ0DDAELIAJBoAFHDQILQQBBACgCpAoiA0ECaiIBNgKkCiADQQAoAqgKSQ0ACwsgAgvCAwEBfwJAIAFBIkYNACABQSdGDQAQIg8LQQAoAqQKIQIgARAYIAAgAkECakEAKAKkCkEAKALICRABQQBBACgCpApBAmo2AqQKQQAQJiEAQQAoAqQKIQECQAJAIABB4QBHDQAgAUECakGyCEEKECtFDQELQQAgAUF+ajYCpAoPC0EAIAFBDGo2AqQKAkBBARAmQfsARg0AQQAgATYCpAoPC0EAKAKkCiICIQADQEEAIABBAmo2AqQKAkACQAJAQQEQJiIAQSJGDQAgAEEnRw0BQScQGEEAQQAoAqQKQQJqNgKkCkEBECYhAAwCC0EiEBhBAEEAKAKkCkECajYCpApBARAmIQAMAQsgABAoIQALAkAgAEE6Rg0AQQAgATYCpAoPC0EAQQAoAqQKQQJqNgKkCgJAQQEQJiIAQSJGDQAgAEEnRg0AQQAgATYCpAoPCyAAEBhBAEEAKAKkCkECajYCpAoCQAJAQQEQJiIAQSxGDQAgAEH9AEYNAUEAIAE2AqQKDwtBAEEAKAKkCkECajYCpApBARAmQf0ARg0AQQAoAqQKIQAMAQsLQQAoAugJIgEgAjYCECABQQAoAqQKQQJqNgIMC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECUNAkEAIQJBAEEAKAKkCiIAQQJqNgKkCiAALwECIgANAAwCCwsgACECCyACQf//A3ELqwEBBH8CQAJAQQAoAqQKIgIvAQAiA0HhAEYNACABIQQgACEFDAELQQAgAkEEajYCpApBARAmIQJBACgCpAohBQJAAkAgAkEiRg0AIAJBJ0YNACACECgaQQAoAqQKIQQMAQsgAhAYQQBBACgCpApBAmoiBDYCpAoLQQEQJiEDQQAoAqQKIQILAkAgAiAFRg0AIAUgBEEAIAAgACABRiICG0EAIAEgAhsQAgsgAwtyAQR/QQAoAqQKIQBBACgCqAohAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AqQKECJBAA8LQQAgAjYCpApB3QALSQEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIAFBAWohASAAQQFqIQAgAkF/aiICDQAMAgsLIAQgBWshAwsgAwsL5AECAEGACAvGAQAAeABwAG8AcgB0AG0AcABvAHIAdABlAHQAYQBmAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGYAbwByAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABByAkLEAEAAAACAAAAAAQAADA5AAA=\",\"undefined\"!=typeof Buffer?Buffer.from(A,\"base64\"):Uint8Array.from(atob(A),(A=>A.charCodeAt(0))))).then(WebAssembly.instantiate).then((({exports:A})=>{C=A}))),E};\n\n//# sourceURL=webpack://garfish-VNode-diff-performance/./node_modules/.pnpm/registry.npmmirror.com+@alioth-org+es-module-lexer@1.1.0/node_modules/@alioth-org/es-module-lexer/dist/lexer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main-app/index.js");
/******/ 	
/******/ })()
;